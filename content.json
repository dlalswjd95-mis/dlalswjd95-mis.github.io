{"meta":{"title":"Dominoly's IT Blog","subtitle":null,"description":null,"author":"Minjeong Lee","url":"http://dlalswjd95-mis.github.io"},"pages":[],"posts":[{"title":"node-js-3","slug":"node-js-3","date":"2018-08-03T15:16:57.000Z","updated":"2018-08-03T15:19:29.216Z","comments":true,"path":"2018/08/04/node-js-3/","link":"","permalink":"http://dlalswjd95-mis.github.io/2018/08/04/node-js-3/","excerpt":"","text":"","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://dlalswjd95-mis.github.io/categories/Node-js/"}],"tags":[{"name":"node.js, database, oracledb, javascript","slug":"node-js-database-oracledb-javascript","permalink":"http://dlalswjd95-mis.github.io/tags/node-js-database-oracledb-javascript/"}]},{"title":"Node.js로 채팅창 구현하기","slug":"node-js-2","date":"2018-08-03T13:18:41.000Z","updated":"2018-08-03T15:18:36.835Z","comments":true,"path":"2018/08/03/node-js-2/","link":"","permalink":"http://dlalswjd95-mis.github.io/2018/08/03/node-js-2/","excerpt":"","text":"Web socket의 등장원래 기존의 웹기반의 기술에서는 html문서를 주고받는 다운로드기반의 http 프로토롤을 쓰기 때문에실시간 연결이 유지되지 않았습니다. 즉, http를 사용하는 웹은 상태를 유지하지 못하기 때문에stateless하다고 표현합니다. 따라서 채팅과 같이 서버와 클라이언트가 지속적인 연결을 유지하는 기술은 구현이 불가능하였습니다.그렇게 때문에 , 채팅을 제작하려면 java, c, c#과 같은 응용 프로그램을 이용해야 했습니다. 그러나 HTML5에서 지원하는 Web Socket과 Node.js의 socket.io를 사용하면 웹상에서도 실시간 통신이가능합니다. 즉, stateful한 것이라고 볼 수 있습니다. 하지만 주의할 점이 있습니다. 웹소켓과 socket.io는 java, c#과 같은 언어에서 지원하는 소켓과는 틀리기 때문에반드시 웹서버 위에서 구동됩니다.따라서 기존에 node.js에서 구현하였던 웹서버 객체들은 그대로 사용해야 합니다. node js로 채팅창 구현하기이전 포스팅에서 짰던 코드를 다시 복습해봅시다. webserver1파일 안에 chatServer.js파일을 생성하고 아래 코드를 입력합니다. 1234567891011var http = require(\"http\"); //http객체 생성var express = require(\"express\"); //express외부모듈 객체로 받기var app = express(); //express생성자 객체생성 var server = http.createServer(app); // 기존 웹 서버 업그레이드 app.use(express.static(__dirname)); //클라이언트의 요청마다 조건문으로 라우팅 처리할 필요없음.server.listen(8989, function()&#123; //이번에는 8989포트에서 서버가동 console.log(\"웹서버 8989에서 가동중...\");&#125;) 8989에서 가동하는 web server를 만들었습니다. 이제 실시간 통신이 가능한 socket server를 만들어 보겠습니다. 이는 웹서버를 기반으로 돌아가기때문에반드시 기존의 web server도 필요하다는 점을 잊으면 안됩니다!! 1var socketio = require(\"socket.io\"); socket.io는 외부모듈이기 때문에 1npm install socket.io 설치를 꼭 해주어야 합니다. socket은 개발자가 네트워크에 대한 지식없이 단지, socketio라는 모듈을 메모리에 올려두고메소드를 통해 조작만 하면 쉽게 구현할 수 있습니다. 웹소켓은 웹기반 가상소켓이기 때문에 반드시 웹브라우저 클라이언트들만 접속이 가능합니다.반면, Net이라는 모듈은 브라우저이외의 어떤 형태의 클라이언트건 다 인식할 수 있습니다.** Net Module : TCP 프로토콜 기반의 소켓 프로그래밍을 지원하는 코어 모듈. 채팅화면을 구현한 client1.html이라는 파일을 webserver1에 만듭니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;접속클라이언트&lt;/title&gt; &lt;style&gt; .wrapper&#123; width: 350px; background: steelblue; &#125; .top&#123; &#125; .top &gt; input&#123; width: 98%; font-size: 25px; background: dodgerblue; color: white; font-weight: bold; &#125; .content &gt; textarea&#123; width: 98%; height: 250px; &#125; .footer&gt;input&#123; width: 98%; height: 30px; &#125; &lt;/style&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; var socket; //대화용 소켓생성 $(function()&#123; //버튼누르면 노드서버에 소켓을 통해 접속! $(\"#bt\").click(function()&#123; socket = io(); //접속이 성공되면, 대화용 소켓이 반환됨!! //서버가 보낸 데이터 받기!! socket.on(\"message\",function(data)&#123; //textarea에 출력한다. var area = document.getElementById(\"area\"); area.append(data.msg+\"\\n\"); &#125;) &#125;); &#125;); //연결되어있는 서버에 메세지 보내기 function enter(obj)&#123; if(event.keyCode === 13)&#123; //메세지를 보내는 이벤트 socket.emit(\"message\", &#123;\"msg\":\"\"+obj.value+\"\"&#125;); obj.value=\"\"; //입력한 글씨 다시 지우기 &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"top\"&gt; &lt;input type=\"button\" value=\"접속\" id=\"bt\"&gt; &lt;/div&gt; &lt;div class=\"content\"&gt; &lt;textarea id=\"area\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt; &lt;input type=\"text\" onkeyup=\"enter(this)\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 접속버튼을 클릭하면 노드 서버에 접속을 시도하고, 성공하면 대화용 socket을 반환합니다.그리고 클라이언트가 입력창에 텍스트를 치고 엔터키를 누르면enter함수가 호출되면서 연결되어있는 서버에 텍스트를 포함한 메시지가 전송됩니다. 이제, 소켓 서버를 가동시키고 , 접속자들을 감지합니다.12345var io = socketio.listen(server); //소켓 서버를 가동!console.log(\"소켓서버도 가동\");io.sockets.on(\"connection\",function(socket)&#123; //sockets는 접속을 걸어온 접속자들을 의미! console.log(\"접속자 발견!!\");&#125;) 접속자들의 socket들을 담을 배열객체를 생성하고,소켓에 접속할 때마다 배열에 socket을 담습니다.그리고 클라이언트가 emit()으로 data를 보냈다면, 받는 쪽에서는 on으로 받습니다.123456789101112131415var socketArray = new Array();//접속한 자의 소켓 배열에 담기!socketArray.push(socket);console.log(\"대화 참여자는 총 %d명\",socketArray.length);//받는 접속자는 on으로 받는다.socket.on(\"message\",function(data)&#123; console.log(data); //방금 전달받은 메세지를 곧바로 다시 클라이언트에게 보낸다. for(var i = 0; i&lt; socketArray.length; i++)&#123; socketArray[i].emit(\"message\", data); &#125;;&#125;); 그럼 client.html에서는 서버가 곧바로 보낸 메세지를 받아서textarea에 출력합니다. 이번 포스팅에서는 간단하게 웹소켓과 node.js를 이용한 stateful한 웹채팅창을 구현해 보았습니다.다음 포스팅은 node.js서버와 database 연동 작업을 하겠습니다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://dlalswjd95-mis.github.io/categories/Node-js/"}],"tags":[{"name":"node.js, javascript, webserver, websocket, stateful, socket, socket.io","slug":"node-js-javascript-webserver-websocket-stateful-socket-socket-io","permalink":"http://dlalswjd95-mis.github.io/tags/node-js-javascript-webserver-websocket-stateful-socket-socket-io/"}]},{"title":"Node.js 구축하기","slug":"node-js-1","date":"2018-08-03T08:03:19.000Z","updated":"2018-08-03T13:45:55.147Z","comments":true,"path":"2018/08/03/node-js-1/","link":"","permalink":"http://dlalswjd95-mis.github.io/2018/08/03/node-js-1/","excerpt":"","text":"웹사이트를 만들기 전에 요청한 정보를 response해줄 서버가 필요합니다.다양한 서버들이 존재하지만 저는 node.js 서버를 구축해보겠습니다!console창을 통해서도 코드 작성이 가능하지만 1회성코드에 불과하기 때문에에디터를 js파일로 저장하여 개발하는 것이 좋아요! node.js는 이미 만들어진 모듈을 가지고 쉽게 구축할 수 있습니다.모듈은 누군가 만들어좋은 소프트웨어 집합을 말하며, 내장모듈과 외장모듈로 나뉘어 지는데요.외장모듈은 말그대로 외부에서 만들어진 모듈입니다. 지금 이 순간에도 다양한 모듈들이 만들어지고 있어요.그래서 따로 설치하는 과정이 필요합니다.반면, 내장모듈은 이미 node.js를 설치함과 동시에 생성된 모듈이기 때문에 따로 설치할 필요가 없습니다. 서버 구축할 파일디렉토리 생성C드라이브 &gt; koreaAcademy &gt; node_workspace &gt; webserver1위와같이 파일을 생성하고webserver1에서 서버를 구축해보도록 하겠습니다. 서버 구축하기webserver1안에 main.js 파일을 생성하여 서버구축을 합니다. 1var http = require(\"http\"); http는 이미 존재하는 내장 모듈로, 위의 코드는 http모듈을 가져오는 과정입니다.앞으로 계속 사용하기 위해 http라는 객체로 받습니다. 1var server = http.createServer(); 웹서버 객체를 생성합니다. 변수명은 마음대로 바꿔도 됩니다. 서버 가동123server.listen(7777,function()&#123; console.log(\"webserver is running at 7777\")&#125;); 웹서버를 가동합니다.단, 다른 네트워크 프로그램과 구분하기 위해 포트번호(7777)를 부여합니다.그리고 웹서버 가동과 동시에 익명함수가 호출되어 webserver is running at 7777이라는문구가 콘솔창에 뜨는 것을 확인하고, 서버가동이 성공했음을 알 수 있습니다. ###클라이언트 요청 받아오기서버 가동만 하지 말고 클라이언트의 요청을 받는 코드를 추가합니다.서버 가동 전에 추가되어야 하겠죠.1234server.on(\"request\",function(request, response)&#123; response.writeHead(200,&#123;\"ContentType\":\"text/html\"&#125;); //성공했다는 응답코드 200을 보내고 response.end(\"서버로부터 온 데이터\"); //응답 문자열을 end메서드의 매개변수로 전달합니다. &#125;); on은 ~할때를 의미하는 이벤트 핸들러 기능을 합니다.request가 들어오면 2번째 인수의 콜백함수가 실행됩니다.request에는 클라이언트의 요청정보가 담겨있습니다. 예를 들어, url주소같은..!response는 클라이언트에게 전송할 응답객체입니다. 이 객체를 이용하면데이터 전송을 할 수 있습니다. ContentType은 클라이언트가 브라우저로 들어오면 html형태로 응답해주어야 하기때문에 값으로 text/html을 줍니다. 콜백함수란 시스템에서 어떠한 이벤트가 발생하면 함수를 불러와 실행되는 것을 의미합니다.원래는 함수를 정의해놓고 개발자가 호출하는 방식이었으나,콜백함수는 개발자가 익명함수를 정의해놓고 어떠한 이벤트가 발생하면시스템이 알아서 그 익명함수를 불러오는 방식입니다. 그러므로, 개발자는 언제 이 함수가호출될 지 모르는 것이죠. 왜냐면 시스템에 의해서 호출되는 함수니까요!! 자, 이제 webserver1파일(서버) 안에 index.html을 만들고클라이언트가 요청하면 불어오는 실습을 해볼게요.아래는 index.html파일로, 이미지를 넣어봤어요. 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;메인페이지&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=\"data:image/jpeg;base64,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\"&lt;/body&gt;&lt;/html&gt; 이 상태에서 서버를 가동해도 파일을 불러올 수 없습니다.특이하게도 node.js는 root디렉토리에 파일을 올려놓는 것만으로 끝나지 않습니다.(tomcat같은경우는 root디렉토리에 파일을 올려두기만 해도 서버에서 불러올수있습니다. ) 우리가 위에서 짠 코드 어디에서도 파일을 읽어들이는 부분이 없기 때문입니다.node.js에는 특정파일을 읽어들이는 fs 모듈이 있습니다.fs모듈을 객체로 받아옵니다.(객체명 변경가능)1var fs = require(\"fs\"); //파일을 읽어들이는 객체, java의 filestring과 동일. 파일을 읽어들이는 것은 논리상 클라이언트로 부터 파일요청을 받은 이후에 실행되어야 합니다.위의 server가동 뒤 콜백함수안에 파일을 읽어들이는 코드를 추가합니다.12345678server.on(\"request\",function(request, response)&#123; fs.readFile(\"index.html\",\"utf-8\",function(error, data)&#123; response.writeHead(200,&#123;\"ContentType\":\"text/html\"&#125;); //이동!! response.end(data); //이동!! 그리고 index.html을 읽어들인 data를 매개변수로 보낸다. &#125;) //response.writeHead(200,&#123;\"ContentType\":\"text/html\"&#125;); //response.end(\"서버로부터 온 데이터\"); &#125;); readFile메서드로 index.html파일을 읽어들인 후 콜백함수를 실행합니다.여기서 콜백함수는 error와 data를 전달해줍니다. error와 data 이름은 바꿔도 상관없습니다.data는 index.html를 담고 있습니다. 다시 서버를 재가동해봐서 확인해보면 브라우저에 우리가 만들었던 index.html파일이 제대로 뜨는 것을확인하실 수 있습니다.이러한 기능을 톰캣이나 아파치는 이미 내부에 존재하기 때문에 root 디렉토리에 넣어두기만 해도 파일을 읽어올 수 있습니다. 여기서 주목할 점이 하나 있습니다.만약 클라이언트가 다른 페이지를 요청한다면 어떻게 될까요? 계속 index.html 파일만을 불러올 것입니다.그럼 이제 ,webserver1파일안에 test.html이라는 새로운 파일을 생성해서 클라이언트의 요청에 따라다른 파일을 불러오는 코드를 짜볼게요.test.html은 바탕이 초록색인 파일입니다.12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=\"green\"&gt;&lt;/body&gt;&lt;/html&gt; main.js로 다시 돌아와 코드를 추가합니다.클라이언트가 요청한 자원을 보여주기에 앞서먼저 url을 분석합니다.그래야 해당 페이지를 보여줄 수 있습니다.request.url과 같은 메서드는 node.js 공식홈페이지에 들어가면 찾아볼 수 있습니다.홈페이지에 없으면..1234567891011121314server.on(\"request\",function(request, response)&#123; if(request.url == \"/index.html\")&#123; fs.readFile(\"index.html\", \"utf-8\",function(error, data)&#123; response.writeHead(200, &#123;\"ContentType\":\"text/html\"&#125;); //성공여부를 알려줌 response.end(data); //응답 문자열을 end()메서드의 매개변수로 전달 &#125;); &#125; else if(request.url == \"/test.html\")&#123; fs.readFile(\"test.html\", \"utf-8\",function(error, data)&#123; response.writeHead(200, &#123;\"ContentType\":\"text/html\"&#125;); //성공여부를 알려줌 response.end(data); //응답 문자열을 end()메서드의 매개변수로 전달 &#125;); &#125; &#125; request메시지의 url을 나타내는 request.url이 /index.html일때, /test.html 일때요청한 파일을 읽어들여 response메시지에 담아 전달했습니다. 자.. 그렇다면 100개 , 1000개의 요청이 있을 때, 일일이 if문을 다 쳐야 할까요?node.js에서는 express라는 외부모듈이 존재합니다.이 모듈을 이용하면 기능의 개선뿐만 아니라 간단한 코드로 구현이 가능합니다.단, 외부모듈이기 때문에 루트리렉토리인 webserver1에 설치를 해야합니다. ** npm이란? Node Packaged Manager의 약자로, node.js로 만들어진 package(module)들을 관리해주는 툴을 말합니다. express모듈을 설치했으면 webserver1에 node_modules라는 파일이 생성된것을 볼 수 있습니다.설치가 제대로 됐다는 것입니다.이제 main.js에서 express를 객체로 받아옵니다.1var express = require(\"express\"); 그리고 express 생성자를 호출합니다.1var app = express(); //1 app이라는 객체로 받아옵니다. 여기서 중요한점!! 객체 app와 객체 http 중 종속적인 요소는 app이기 때문에http서버를 업그레이드 시킨다는 의미로 1var server = http.createServer(app); 위와 같이 기존의 코드를 바꿔줍니다.이제, express의 지원을 받는 서버가 되었습니다.논리상 1번이 먼저오고, 그 다음에 2번 줄이 와야 합니다. express 모듈은 미들웨어라 불리는 각종 기능들을 지원하는데,이 미들웨어를 호출할 때는 use()메서드를 사용합니다. 1app.use(express.static(__dirname)); 정적 자원들의 위치를 알려주는 static메서드를 사용하고그리고 __dirname이라는 변수를 통해지금 실행중인 파일의 디렉토리를 가져올 수 있습니다. ** __ 가 붙은 형태의 변수는 node.js의 전역변수입니다. 이미 개발자가 정해놓은 변수이다. express로 업그레이드 하기 전에는 클라이언트의 요청을 받는 메서드가 server.on이었으나,express에서도 요청을 처리하는 use라는 메서드가 지원됩니다. 기존과 동일한 기능을 하도록 구현해 보겠습니다.만약 초록배경의 test.html을 가져오고 싶으면123456app.use(\"/green\", function(request, response)&#123; fs.readFile(\"test.html\",\"utf-8\",function(error, data)&#123; response.writeHead(200,&#123;\"ContentType\":\"text/html\"&#125;); response.end(data); &#125;)&#125;); 첫 번째 인수로 /green을 주었는데 이는 가상의 mapping, routing이라고 합니다.즉, /green을 /chorok으로 바꿔도 똑같은 파일을 라우팅해주는 것입니다. 이제 server.on과 비슷한 express.use라는 것으로 간단하게, restful하게 바꿔보았습니다. 이번 포스팅은 nodejs서버 생성, 가동, 그리고 요청한 파일을 가상의 매핑을 통해 불러오는 것을 간단하게 실습해보았습니다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://dlalswjd95-mis.github.io/categories/Node-js/"}],"tags":[{"name":"node.js, javascript, webserver","slug":"node-js-javascript-webserver","permalink":"http://dlalswjd95-mis.github.io/tags/node-js-javascript-webserver/"}]},{"title":"_reduce함수-part2","slug":"reduce함수","date":"2018-07-12T05:46:56.000Z","updated":"2018-07-12T07:12:48.908Z","comments":true,"path":"2018/07/12/reduce함수/","link":"","permalink":"http://dlalswjd95-mis.github.io/2018/07/12/reduce함수/","excerpt":"","text":"_reduce_reduce함수의 형태는 이렇습니다. 123_reduce(list, iter, memo)&#123; &#125; 첫번째인자(list) : 배열두번째인자(iter) : 함수세번째인자(memo) : 축적된 값 만약 list에 1~3이 존재하고 함수로 그들을 더하는 add함수가 있다고 가정하면 , 12console.log( _reduce([1, 2, 3], add, 0)); 위의 결과가 6이 나오도록 해주는 것이 _reduce함수입니다.어떤 함수나 list가 들어와도 reduce함수를 이용하면 재귀적수행을 쉽게 할 수 있습니다. 위의 예시의 동작순서를 설명하겠습니다. 1memo = add(0,1) add함수에 memo의 처음값 0과 배열의 시작값 1을 주고그 결과값을 memo에 줍니다. 1memo = add(memo, 2) 그 다음, 위에서 축적된 memo값이 다시 add함수의 첫번째 인자로 들어가고,배열의 두번째 값 2가 add함수의 두번째 인자로 들어갑니다.이제 memo값은 3이 되었습니다. 123456789memo = add(memo, 3)return memo;``` 이어서 똑같이 배열의 마지막값인 3까지 최종적으로 더해져서 memo는 6으로 리턴됩니다.즉, ```jsadd(add(add(0,1),2),3); _reduce함수는 위처럼 재귀적으로 add함수가 실행된 결과를 만들어주는 역할을 합니다. 123function _reduce(list, iter, memo)&#123; iter(iter(iter(0,1),2),3); &#125; 이런식으로 list의 수만큼 재귀적으로 함수를 수행하는 _reduce함수를 구현해봅시다! 앞 포스팅에서 공부했던 _each함수를 사용하면 쉽게 반복되는 작업을 처리할 수 있습니다. 123456function _each(list, iter)&#123; for(var i =0 ; i &lt; list.length; i++) &#123; iter(list[i]); &#125; return list; //없어도 실행되는데 문제는 없음.&#125; each 함수는 list와 iter함수를 인수로 받아서 list의 값 하나하나 함수에 반복적용하는 역할을 합니다. 123456789function _reduce(list, iter, memo)&#123; _each(list, function(val)&#123; memo = iter(memo, val); &#125;); return memo; &#125;console.log( _reduce([1,2,3], add, 0)) 결과값은 6이 나올 것입니다. 동작순서는 다음과 같습니다. _reduce를 호출합니다.인자로 1~3까지의 배열, 인자두개를 받아 더하는 add함수, 처음 더해지는 값 0 을 보냅니다. _each함수가 실행됩니다.인자로 1~3까지의 배열, val을 인자로 받는 함수가 보내집니다.이 때, val값은 _each로 인해 list의 i번째 요소들이 들어갑니다. _each함수 수행결과 값 6을 리턴합니다. _reduce함수는 두번째인자로 받은 함수를 연속적으로 대신해서 호출해주고값을 계속해서 하나의 값으로 축약해 나가는 함수입니다. 이 함수는 복잡하고 반복적인 로직을 축약할때 아주 유용하게 사용될 수 있습니다. _reduce함수는 세번째 인자(memo)를 생략하여 사용할 수도 있습니다. 위에서 만약 세번째 인자가 10이라면 16이라는 결과값을 얻게 되겠죠 . 그런데 세번쨰 인자가 없더라도 배열의 첫번째값이 memo가 되어 수행되면 더 좋겠죠. 그러기 위해서 아래처럼 _reduce에 조건을 넣어줍니다. 12345678910function _reduce(list, iter, memo)&#123; if(arguments.length == 2)&#123; memo = list[0]; list = list.slice(1); &#125; _each(list, function(val)&#123; memo = iter(memo, val); &#125;); return memo; &#125; 위에서 쓰인 slice 메소드는 slice(없애고싶은 배열개수) 형태를 띕니다.즉, 우리는 이미 배열의 첫번째를 처음 초기값으로 지정했기 때문에중복으로 더해지는 것을 막기위해 배열첫번째를 없애 줘야합니다.그래서 , slice를 이용하는데요. 문제는 slice가 메소드이기 때문에 list가 무조건 Array객체일 때만 가능하다는 점입니다.arraylike 객체에는 작동하지 않습니다. 아무튼, 이런 문제를 해결할 수 있는 방법은 다음과 같습니다.새롭게 _rest 라는 함수를 만듭니다. 123function _rest(list, num)&#123; return slice.call(list, num || 1); &#125; _rest함수는 인자로 list와 list에서 잘라낼 갯수를 의미하는 num을 가지고,원래 list에서 num만큼 잘라낸 list를 리턴합니다. 만약 num이 없으면 default값으로 1을 리턴합니다.그럼이제, _rest를 사용해서 _reduce의 문제를 해결해 봅시다! 12345678910function _reduce(list, iter, memo)&#123; if(arguments.length == 2)&#123; memo = list[0]; list = _rest(list) &#125; _each(list, function(val)&#123; memo = iter(memo, val); &#125;); return memo; &#125; 이 함수를 활용하면 재밌는 로직을 만드는 데 도움이 된다고 하네요. _reduce함수에 대한 포스팅을 마치겠습니다!!","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://dlalswjd95-mis.github.io/categories/Javascript/"}],"tags":[{"name":"_reduce, reduce, programming, 함수형프로그래밍, javascript","slug":"reduce-reduce-programming-함수형프로그래밍-javascript","permalink":"http://dlalswjd95-mis.github.io/tags/reduce-reduce-programming-함수형프로그래밍-javascript/"}]},{"title":"_get함수만들기 - part2","slug":"get함수만들기","date":"2018-07-11T11:06:40.000Z","updated":"2018-07-11T11:24:05.773Z","comments":true,"path":"2018/07/11/get함수만들기/","link":"","permalink":"http://dlalswjd95-mis.github.io/2018/07/11/get함수만들기/","excerpt":"","text":"_get이 함수는 object와 원하는 key를 인자로 받아서 object의 key로 접근하여원하는 결과를 리턴합니다. _get함수는 아래와 같습니다 . 123function _get(obj, key)&#123; return obj[key];&#125; 그런데 만약 obj가 null값이거나 undefinde라면 error가 발생할 것입니다._get에 아래와 같이 조건을 추가해서 문제를 해결할 수 있습니다. 123function _get(obj, key)&#123; return obj == null ? undefined : obj[key]; &#125; 자, 만약 users라는 배열의 첫번째 객체의 ‘name’ 값을 얻고 싶다면 아래처럼 접근하면 되겠죠. 123var user1 = users[0]; console.log(user1.name); console.log(_get(user1,'name')); 만약, users에 없는 10번째 유저의 ‘name’값을 호출하게 된다면 error가 날것입니다. 하지만, _get함수를 사용하게 되면 오류가 나지 않고 undefined값을 내보낼 것이기 떄문에에러가 나지 않습니다. 그래서 좀더 안전한 코딩을 할 수 있게 됩니다. 이번엔, _get을 만들때 이전 포스팅에서 학습했던 _curry를 이용해서 이전에 만들어 놓았던 코드를 더 간결하게 만들어보겠습니다. 먼저, _get함수를 아래와 같이 _curryr을 통해서 정의해 보겠습니다. 123var _get = _curryr(function(obj, key)&#123; return obj == null ? undefined : obj[key];&#125;); 그럼 평가순서를 뒤집어서 인자 중에 맨 오른쪽(‘name’)부터 적용할 수 있습니다. 1console.log(_get('name')(user1)); 이런식으로, name을 먼저꺼내고, 그 다음 user1을 꺼낼 수 있습니다. 즉, _get(‘name’) 이것 자체가 name을 꺼내는 함수가 됩니다. 1var get_name = _get('name'); get_name 이라는 함수객체를 생성할 수 있겠네요. 만약, get_name이라는 함수에 user1을 넣으면 name값을 확인해 볼 수 있습니다. 기존에 만들었던 코드를 불러와 _get함수를 적용해 보겠습니다. 123456789console.log( _map( _filter(users, function(user)&#123;return user.age &gt;= 30;&#125;), function(user)&#123;return user.name;&#125;)); console.log( _map( _filter(users, function(user)&#123;return user.age &lt; 30;&#125;), function(user)&#123;return user.age;&#125;)); 위의 코드에서 function(user){return user.name;} 이부분을 _get(‘name’)으로 바꿔주기만 하면 됩니다. 그럼, 아래처럼 훨씬 간결하게 코드를 짤 수 있습니다. 12345console.log( _map(_filter(users, function(user)&#123;return user.age &gt;= 30;&#125;), _get('name')));console.log( _map(_filter(users, function(user)&#123;return user.age &lt; 30;&#125;), _get('age'))); 간단하게 커링에 이어서 get함수에 대해서 공부해보았는데요.지금까지 배운 강의중에 제일 이해하기 어려웠던 부분이었던 것 같네요.. 하지만, 이정도로 포기하지 않습니다^^하하 다음 강의는 reduce라는 함수에 대한 것이네요. 화이팅입니다 !!","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://dlalswjd95-mis.github.io/categories/Javascript/"}],"tags":[{"name":"_get, get, javascript, programming, 함수형프로그래밍","slug":"get-get-javascript-programming-함수형프로그래밍","permalink":"http://dlalswjd95-mis.github.io/tags/get-get-javascript-programming-함수형프로그래밍/"}]},{"title":"커링함수만들기(_curry,_curryr)-part2","slug":"커링함수만들기-curry-curryr","date":"2018-07-11T09:47:24.000Z","updated":"2018-07-11T11:01:16.409Z","comments":true,"path":"2018/07/11/커링함수만들기-curry-curryr/","link":"","permalink":"http://dlalswjd95-mis.github.io/2018/07/11/커링함수만들기-curry-curryr/","excerpt":"","text":"커링(Curry) 커링이란 다중 인수 (혹은 여러 인수의 튜플)을 갖는 함수를 단일 인수를 갖는 함수들의 함수열로 바꾸는 것을 말한다. 한마디로, 함수에 인자를 하나씩 적용해 나가다가 필요한 인자가 모두 채워지면 함수 본체를 실행하는 기법입니다. 자바스크립트에서는 커링기법이 지원되지 않지만 앞에 포스팅에서 다뤘듯이 자바스크립트는 일급함수가 지원되고, 얼마든지 평가시점을 마음대로 다룰 수 있기 때문에 커링과 같은 기법을 구현할 수 있습니다. 커링함수는 다음과 같습니다. 1234567function _curry(fn)&#123; return function(a)&#123; return function(b)&#123; return fn(a, b); &#125; &#125; &#125; 커링은 인자로 함수(fn)를 받고, 커링함수를 실행하는 즉시 안쪽함수가 리턴됩니다. 그리고 a라는 인자를 받은 뒤 또 b를 인자로 받는 함수가 리턴됩니다. b를 인자로 받으면 fn(a,b)이라는 본체함수가 실행됩니다. 만약 인자 두개를 받아서 더하는 add함수를 만든다고 하면 일반적으로 아래와 같이 만듭니다. 1234var add= function(a, b)&#123; return a+b; &#125;; console.log(add(10,5)); 결과값으로 15라는 결과를 얻겠죠. 커리함수같은 경우에, add함수를 만들때 아래처럼 _curry로 감싸주기만하면add함수는 커링이 되는 함수로 구현됩니다. 123var add= _curry(function(a, b)&#123; return a+b; &#125;); 함수가 동작하는 순서는 다음과 같습니다. add라는 함수를 만들때 _curry로 감쌉니다. add라는 함수는 fn이 됩니다. add함수는 return fn(a, b); 이곳에 위치하게된다. 123456789101112function(a)&#123; return function(b)&#123; return fn(a, b); &#125; ``` 이 부분이 제일 처음 호출된다. 다시말해, ```jsvar add = function(a)&#123; return function(b)&#123; return fn(a, b); &#125; 위처럼 된다고 볼수있겠다. 인자 a를 먼저 받고, 그 다음에 b를 받은 다음에, 처음에 받아두었던 fn이 나중에 실행된다. 아래 예제를 통해 이해를 도와봅시다ㅎㅎ 결과값 맞춰보기12var add10 = add(10);console.log(add10(5)); 결과값은?? 10+5인 15가 됩니다. 동작순서는 다음과 같습니다. 먼저 인자 10을 받은 add함수의 리턴값이 add10이라는 객체로 들어갑니다. 1234var add10 = function(10)&#123; return function(b)&#123; return fn(a, b); &#125; add10 이라는 함수에 인자 5가 들어갑니다. 그리고, add10이 실행되는 즉시 1234567891011function(b)&#123; return fn(a, b); &#125;``` 이부분이 실행됩니다. 인자 b에 5가 들어가구요. 3. 그럼 본체함수인 fn(a,b)가 실행됩니다. ```jsfunction(a, b)&#123; return a+b; &#125; 바로 이부분이 fn이었죠.그래서 a에는 10, b에는 5가 차례대로 모두 받아졌을때본체함수가 실행되어 5 + 10 인 15라는 결과값을 얻게됩니다. 그래서 ,12console.log(add(5)(3)); //1console.log(add(10)(3)); //2 1번은 결과가 8이되고2번은 13이 됩니다. ‘‘‘ 결국은, 본체함수인123function(a, b)&#123; return a+b; &#125; 이 부분을 값으로 들고있다가 나중에 원하는 시점에 최종적으로 평가하는 기법입니다. 계속해서 이러한 기법을 통해서.함수가 함수를 대신 실행하거나, 함수가 함수를 리턴하면서함수를 조합해 나가는 것이 바로 함수형 프로그래밍입니다. _curry는 함수형 프로그래밍의 응용사례를 잘 보여주고 있습니다._curry함수로 적용했을 때에는 함수로 인자를 하나만 적용하게 되면 함수를 리턴하게 됩니다. 하지만 위의 방식으로는console.log(add(1,2));이것의 결과값은 3이 아니라 함수를 리턴하게 됩니다. 그 이유는 123function(b)&#123; return fn(a, b);&#125; 위의 함수를 리턴하는 것에서 그치기 때문입니다.만약 커리함수를 위처럼 인자두개가 들어오면 함수를 리턴하지 않고즉시 값을 도출하게끔 만들려면 조건문을 추가합니다. 12345678function _curry(fn)&#123; return function(a,b)&#123; if(agument.length == 2) return fn(a, b); return function(b)&#123; return fn(a, b); &#125; &#125; &#125; 위처럼 조건문을 통해서 인자값이 2개면 본체함수를 실행하도록 만들수 있습니다. 하지만 저기에도 return을 두번한다는 문제가 있어요.그래서 그걸 해결하기 위해 아래처럼 수정합니다. 12345function _curry(fn)&#123; return function(a,b)&#123; return agument.length == 2 ? fn(a, b) : function(b)&#123; return fn(a, b);&#125;; &#125; &#125; 이번에는 인자 두개를 받아서 빼기를 하는 함수를 구현해보겠습니다. 12345 var sub = _curry(function(a,b)&#123; return a - b; &#125;);console.log(sub(10, 5)); 결과값은 5가 되겠죠. 더 나아가서12var sub10 = sub(10); console.log(sub10(5)); 위를 실행하면, 5가 됩니다. 하지만 , 표현이 좋지만은 않습니다. sub10이라는 객체에 sub(10)이라는 함수가 들어오고sub10(5)라는 것은 sub(10)함수안에 5가 들어간 것이라고 볼 수 있습니다. 그렇게 되면, 들어오는 인자인 5에 sub10이라는 함수를 적용하는것이니까5-10이 되어야 좀 더 자연스러운 표현같지 않나요…?12console.log(sub(10, 5)); //1console.log(sub10(5)); //2 1번경우는 10-5가 자연스럽지만, 2번은 5에 10을 빼는 것처럼 표현되죠. 그래서 표현을 좀더 자연스럽게 하기위해서 원래 같은 경우 _curry는 왼쪽에서 부터 인자를 적용해나가는데, 새롭게 _curryr이라는 함수를 생성해서 오른쪽에서부터 인자를 적용해나가도록 할 수 있습니다. _curry뿐만아니라 다른 함수에서도 자연스러운 표현을 위해서 뒤에 r이라고 많이 붙인다고 해요. r은 right를 의미하겠죠!하하 _curryr은 _curry와 같은 동작을 하지만 단지, 오른쪽에서부터 인자를 적용해 나간다~ 는 점만 다를 뿐입니다!! _curryr은 다음과 같습니다. 12345function _curryr(fn)&#123; return function(a, b) &#123; return agument.length == 2 ? fn(a, b) : function(b)&#123; return fn(b, a);&#125;; &#125; &#125; 인자값이 2개일 때는 아까처럼 순서대로 적용하지만,인자가 1개인 경우에는 return fn(b, a); 이런 식으로 a와 b의 순서를 바꿔두번째 인자에서 처음에 들어왔던 인자를 빼도록 합니다. 그럼 위의 2번은 5 - 10 인 -5가 리턴됩니다. 지금까지 커링기법에 대해서 알아봤어요. 다음 포스팅은 원하는 값을 얻어오는 _get함수에 대해서 다룰게요ㅎㅎ","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://dlalswjd95-mis.github.io/categories/Javascript/"}],"tags":[{"name":"javascript, _curry, _curryr, programming","slug":"javascript-curry-curryr-programming","permalink":"http://dlalswjd95-mis.github.io/tags/javascript-curry-curryr-programming/"}]},{"title":"오라클 Intro (user생성 및 테이블작성)","slug":"오라클intro","date":"2018-07-08T05:39:26.000Z","updated":"2018-07-08T06:41:10.607Z","comments":true,"path":"2018/07/08/오라클intro/","link":"","permalink":"http://dlalswjd95-mis.github.io/2018/07/08/오라클intro/","excerpt":"","text":"Oracle Intro가장 먼저 (ctrl + R) 후, cmd 입력해서 콘솔창을 엽니다. frontspace라는 DBF 파일을 생성합니다. 오라클에서는 tablespace라는 큰 개념을 이용합니다. 12345SQL&gt; create tablespace frontspace 2 datafile &apos;C:\\oraclexe\\app\\oracle\\oradata\\XE\\frontspace.dbf&apos; 3 size 2M;Tablespace created. frontspace라는 db를 생성합니다. 개발자를 위한 새로운 user를 생성합니다.123456SQL&gt; create user dominonly 2 identified by 1234 3 default tablespace frontspace 4 quota unlimited on frontspace;User created. db를 관리하는 dba가 아닌 개발자는 database를 건드릴 수 있는 권한이 없기 때문에 관리자로부터 권한을 받아내야 합니다. 그러기 위해서는 db에 새로운 자신의 계정을 생성한 뒤에, dba로부터 권한을 받아야 합니다. 실제 실무에서 db를 건드려야 하는 상황이 왔을때, 함부로 db password나 name을 요구하면 스파이로 오해받을 수 있습니다^^;;; 저같은 경우 계정명-&gt; dominonly, 패스워드-&gt; 1234로 설정하였습니다. db를 생성할때 default로 입력될 tablespace를 위에서 만들었던 frontspace로 셋팅합니다. 수정은 ed 라는 편집기로 가능합니다(여기서는 ;이 아니라 /로 문장이 끝났음을 알려줍니다.) 생성된 유저를 확인해봅니다.123456789SQL&gt; run 1 create user dominonly 2 identified by 1234 3 default tablespace frontspace 4* quota unlimited on frontspacecreate user front *ERROR at line 1:ORA-01920: user name &apos;FRONT&apos; conflicts with another user or role name 새로운 cmd창을 열어 생생된 user로 접속해봅니다.123456789C:\\Users\\Leeminjeong&gt;sqlplusSQL*Plus: Release 11.2.0.2.0 Production on 토 7월 7 09:56:08 2018Copyright (c) 1982, 2014, Oracle. All rights reserved.Enter user-name: front/frontERROR:ORA-01045: user FRONT lacks CREATE SESSION privilege; logon denied 접속권한 오류가 뜨는 것을 확인할 수 있습니다. 다시 이전 cmd창으로 와서 생성한 계정에 권한을 부여합니다.123SQL&gt; grant create session to dominonly;Grant succeeded. 두번째 cmd창에서 접속된 것을 확인해 볼 수 있습니다.1234Enter user-name: dominonly/1234Connected to:Oracle Database 11g Express Edition Release 11.2.0.2.0 - 64bit Production 첫번째 cmd에서 user에게 table을 만드는 권한도 부여합니다.123SQL&gt; grant create table to dominonly;Grant succeeded. table을 만듭니다.저는 fruit의 정보를 담은 table을 생성해 보았습니다. 12345678SQL&gt; run 1 create table fruit( 2 name varchar(20) 3 , price number default 0 4 , loc varchar(30) 5* )Table created. 이제 table의 데이터를 생성합니다.12345678910111213141516171819SQL&gt; insert into fruit(name,price,loc) values(&apos;배&apos;,2000,&apos;나주&apos;);1 row created.SQL&gt; insert into fruit(name,price,loc) values(&apos;사과&apos;,1000,&apos;대구&apos;);1 row created.SQL&gt; insert into fruit(name,price,loc) values(&apos;참외&apos;,1500,&apos;성주&apos;);1 row created.SQL&gt; insert into fruit(name,price,loc) values(&apos;바나나&apos;,3000,&apos;필리핀&apos;);1 row created.SQL&gt; insert into fruit(name,price,loc) values(&apos;딸기&apos;,4000,&apos;이마트&apos;);1 row created. 5개의 데이터를 담아보았습니다.여기서 중요한데, commit이라는 과정을 꼭 거쳐야지만 입력된 데이터를확정시킬 수 있습니다. commit을 하지 않으면 애써 입력한 데이터들을 모두잃을 수 있으니까 유의해야합니다. Commit 해서 확정시킵니다.1234SQL&gt; commit;Commit complete. table을 확인해봅니다.12345678910SQL&gt; select * from fruit;NAME PRICE LOC---------------------------------------- ---------- ------------------------------------------------------------배 2000 나주사과 1000 대구참외 1500 성주바나나 3000 필리핀딸기 4000 이마트 만약 table의 가로길이를 조절하고 싶다면SQL&gt; set line 300; 라고 입력하면 됩니다. oracle나가기!!12SQL&gt; exitDisconnected from Oracle Database 11g Express Edition Release 11.2.0.2.0 - 64bit Production 간단하게 exit이라고 입력하면 나갈수있습니다.","categories":[{"name":"oracle","slug":"oracle","permalink":"http://dlalswjd95-mis.github.io/categories/oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://dlalswjd95-mis.github.io/tags/oracle/"}]},{"title":"다형성-part2","slug":"다형성","date":"2018-07-02T10:37:15.000Z","updated":"2018-07-10T06:23:11.470Z","comments":true,"path":"2018/07/02/다형성/","link":"","permalink":"http://dlalswjd95-mis.github.io/2018/07/02/다형성/","excerpt":"","text":"이번에는 다형성에 대해 알아볼게요! 이미 존재하는 filter, map 메소드우리가 그동안 만들었던 세가지 함수(_filter, _each, _map)는 이미 자바스크립트에 존재하는 메소드들입니다. 먼저 _map 함수와 같은 기능을 하는 map이라는 메소드를 살펴보겠습니다.12345console.log( [1,2,3].map(function(val)&#123; return val*2; &#125;) ); map은 Array라는 내장객체에 이미 존재하는 함수입니다.배열에 map이라는 함수를 적용하고, val이라는 값을 받아 배열 순서대로 2를곱하여 결과값을 리턴합니다. 이번에는 filter 메소드를 살펴보겠습니다. 12345console.log( [1,2,3,4].filter(function(val)&#123; return val % 2; &#125;) ); filter함수도 Array 객체안에 이미 존재하는 함수입니다.이번에는 1부터 4까지 배열을 받아 2로 나누어 지지 않는 것들을 차례로 리턴해줍니다. 메소드를 따로 함수로 정의하는 이유 하지만 우리가 그동안 왜 이미있는 것들을 만들었는지 궁금하지 않나요? 그 이유는 이미존재하는 함수는 사실 함수가 아니라 Array객체의 메소드 입니다. 그렇기 떄문에 해당 instance가 아니면 사용할 수 없습니다. 즉, Array가 아닌 객체들에서는 사용할 수 없다는 것이죠. 그래서, 다형성을 지원하기 어려운 부분이 있습니다. 하지만, 함수가 기준이 되는 함수형 프로그래밍에서는 함수를 먼저 만들고, 그 함수에 맞는 데이터을 구성해서 함수에 적용하는 식으로 프로그래밍을 하게 됩니다. 이는 굉장히 유연하고 실용적인 형태라고 볼 수 있겠죠! 그래서 12345console.log( document.querySelectorAll('*').map(function(node)&#123; return node.nodeName; &#125;) ); 위를 실행하게 되면Uncaught TypeError: document.querySelectorAll(…).map is not a function이와같이 map이라는 메소드가 실행되지 않는 것을 볼 수 있습니다. 실제로, 1alert(document.querySelectorAll('*')); 를 해보면 배열과 같은 형태를 갖추고 있는 것을 확인할 수 있습니다. 하지만, 이는 array_like 로 실제 Array객체가 아닌 NodeList라는 프로토타입을 가지는걸 확인하실수있습니다.그렇기 때문에 Array객체의 메소드인 map이 실행되지 않는 다는 뜻이죠. 반면에 , 우리가 만들었던 _map함수를 이용하면12345console.log( _map(document.querySelectorAll('*'), function(node)&#123; return node.nodeName; &#125;) ); 결과값 1// (7) [\"HTML\", \"HEAD\", \"META\", \"TITLE\", \"BODY\", \"SCRIPT\", \"SCRIPT\"] 위와 같이 제대로 된 결과를 얻을 수 있습니다. 외부 다형성과 내부 다형성123_map([1,2,3,4], function(v)&#123; return v + 10; &#125;); 위에서 function(v){return v+10} 부분을 콜백함수라고 부르기도 합니다.함수형프로그래밍에서는 두번째 함수가 어떤 역할을 하는 함수인지에 따라서 다양한 이름을 가지는 것이 중요합니다.콜백함수는 무조건 어떤일을 다~ 수행된 다음에 디시 돌려주는 것을 뜻하는 데요. 이전에 우리가 만들었던 두번째 함수인 predi, iter, mapper 처럼 각각의 역할이 다른 함수들을 다르게 이름짓는 것이 좋습니다이런 두번쨰 함수들을 보조함수라고 부르는데 , _map, _each, _filter가 외부에서 큰 틀을 잡았다면(외부 다형성) , 이 보조함수들은 실제로 개발자가 원하는 일들을 수행시키기 위해 정의하는 부분(내부 다형성)이라고 보면 되겠습니다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://dlalswjd95-mis.github.io/categories/Javascript/"}],"tags":[{"name":"javascript, 다형성, programming","slug":"javascript-다형성-programming","permalink":"http://dlalswjd95-mis.github.io/tags/javascript-다형성-programming/"}]},{"title":"함수형으로전환하기(_each) - part2","slug":"함수형으로전환하기-each함수","date":"2018-07-02T08:55:53.000Z","updated":"2018-07-02T10:35:32.692Z","comments":true,"path":"2018/07/02/함수형으로전환하기-each함수/","link":"","permalink":"http://dlalswjd95-mis.github.io/2018/07/02/함수형으로전환하기-each함수/","excerpt":"","text":"보시면 _filter와 _map함수에서 중복되는 코드를 확인하실 수 있습니다....중복되는 부분 for문(루프) 해당 i번째 list를 참조하는 부분 위의 중복되는 부분을 _each라는 함수로 따로 빼내서 제거할 수 있습니다. 123456function _each(list, iter)&#123; for(var i =0 ; i &lt; list.length; i++) &#123; iter(list[i]); &#125; return list; //없어도 실행되는데 문제는 없음.&#125; 이 _each라는 함수는 인자로 list와 iter를 받아서 반복을 하는 함수입니다.중복되는 for문을 그대로 가져오고, 받은 값을 그대로 리턴합니다. 간단히 말해 _each함수는 for문의 역할을 완전히 위임하는 함수라고 보면 됩니다. 먼저 _filter함수를 _each함수로 리펙토링합니다. 12345678function _filter(list, predi)&#123; var new_list = []; _each(list, function(val)&#123; if(predi(val)) new_list.push(val); &#125;); return new_list;&#125; _each(list, function(val)) –&gt; _each함수에서 list의 특정 i번째 요소를 하나하나씩 꺼내서 iter함수를 실행시킵니다.위에서는 iter함수로 function(val){ if(predi(val)) new_list.push(val);} 를 보냅니다. 특정 i번째 요소들이 val로 들어가고predi라는 조건이 true일때 val값이 new_list에 담겨 리턴됩니다. 그다음 _map함수도 _each함수로 리펙토링합니다. 1234567function _map(list, mapper)&#123; var new_list = []; _each(list, function(val)&#123; new_list.push(mapper(val)); &#125;); return new_list;&#125; _each함수에서 꺼내진 특정 i번쨰 요소들은 mapper에게 보냅니다.여기에서는 mapper가 특정 i번쨰 요소의 name이나 age를 리턴합니다.mapper(val)의 리턴값이 new_list에 담겨지고, 최종적으로 new_list를 리턴합니다. .... 다음 포스팅에서는 다형성에 대해서 배워볼게요!","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://dlalswjd95-mis.github.io/categories/Javascript/"}],"tags":[{"name":"javascript, FR, each, programming","slug":"javascript-FR-each-programming","permalink":"http://dlalswjd95-mis.github.io/tags/javascript-FR-each-programming/"}]},{"title":"함수형으로 전환하기(_filter, _map)- part 2","slug":"함수형으로전환하기","date":"2018-06-28T13:39:56.000Z","updated":"2018-07-02T08:57:57.395Z","comments":true,"path":"2018/06/28/함수형으로전환하기/","link":"","permalink":"http://dlalswjd95-mis.github.io/2018/06/28/함수형으로전환하기/","excerpt":"","text":"이번에는 아래와같은 문제를 명령형 프로그래밍코드로 해결한 뒤 , 함수형 프로그래밍으로 refactoring 하도록 하겠습니다. 12345678910var users = [ &#123;id:1, name: 'ID', age:36&#125;, &#123;id:2, name: 'BJ', age:32&#125;, &#123;id:3, name: 'JM', age:32&#125;, &#123;id:4, name: 'PJ', age:27&#125;, &#123;id:5, name: 'HA', age:25&#125;, &#123;id:6, name: 'JE', age:26&#125;, &#123;id:7, name: 'JI', age:31&#125;, &#123;id:8, name: 'MP', age:23&#125; ]; users라는 배열이 존재합니다. json표기법을 따르고 있네요..ㅎㅎ 이 배열은 id, name, age를 가지는 8개의 객체를 포함합니다. 위의 배열로 4가지 문제를 해결해 봅시다. 나이가 30세 이상인 user를 거른다. 걸러진 user들의 name을 수집한다. 나이가 30세 미만인 user를 거른다. 걸러진 user들의 age를 수집한다. 나이가 30세 이상인 user를 거른다. 1234567 var user_over30 =[];for(var i=0; i&lt; users.length; i++)&#123; if(users[i].age &gt;= 30)&#123; user_over30.push(users[i]); &#125;&#125;console.log(user_over30); user_over30이라는 빈 배열을 생성하고, for문으로 users배열 객체하나하나의 나이를 체크하여 30이 넘는 객체를 배열 user_over30 에 담아 콘솔창으로 확인합니다. 결과값30세 이상인 user만 제대로 걸러냈습니다. 걸러진 user들의 name을 수집한다. 12345var names = [];for(var i =0 ; i&lt; user_over30.length ; i++)&#123; names.push(user_over30[i].name);&#125;console.log(names); 이번에는 30세 이상인 user들의 name이 담길 names라는 배열을 새롭게 생성합니다. 그리고 for문을 돌려 i번째 user_over30의 이름을 하나씩 배열에 담습니다. 결과값30세 이상인 user이 name을 수집했습니다. 나이가 30세 미만인 user를 거른다. 걸러진 user들의 age를 수집한다. 123456789101112131415//3. 30세 미만인 users를 거른다. var users_under30 = []; for(var i=0; i &lt;users.length; i++)&#123; if(users[i].age &lt; 30)&#123; users_under30.push(users[i]); &#125; &#125; console.log(users_under30 ); //4. 30세 미만인 users의 ages를 수집한다. var ages = []; for(var i =0; i &lt; users_under30.length; i++)&#123; ages.push(users_under30[i].age) &#125; console.log(ages); 이번은 위의 1번 2번에서 나이 조건을 30세 미만으로 바꾸기만 하면 됩니다. 결과값30세 미만인 user와 그들의 age를 제대로 가져왔습니다. ... 지금까지는 명령형 코드로 프로그래밍했습니다.이제 함수형으로 전환하여 중복코드를 제거하고좀 더 다형적이며 활용성 높은 코드로 바꿔보도록 합시다!!!... 먼저 30세이상인 코드와 미만인 코드의 중복을 줄이고 싶네요.. 함수형프로그래밍에서 쉽게 줄일수있습니다^^ 이 문제는 filter라는 함수를 통해 가능하답니다. _filter 로 리펙토링!! filter라는 순수함수를 새롭게 생성하고 그냥 외부에서 변수를 받아와 필요한 시점에서만 사용되도록 만드는 것… 12345678910111213141516function _filter(list, predi)&#123; //여러번 사용할것을 감안해 users--&gt; list로 바꾸는것이좋음. var new_list = []; // 위처럼 여러번 사용될 것이기 때문에 user_over30, user_under30 --&gt; new_list로 바꾸는게 좋아요.. for(var i=0; i &lt; users.length; i++)&#123; if(predi(users[i])) &#123; //predi는 i번째 users라는 인자값을 받아 user.age &gt;= 30 라는 new_list.push(users[i]); &#125; &#125; return new_list;&#125; var over_30 = _filter(users, function(user)&#123;return user.age &gt;= 30;&#125;); console.log(over_30); var under_30 = _filter(users, function(user)&#123;return user.age &lt; 30 ;&#125;); console.log(under_30); _filter라는 함수는 list, predi라는 인자를 받습니다.list, 즉 array 타입으로된 어떤 배열이 와도 됩니다. predi는 함수이고,어떠한 판별 조건을 리턴해주는 역할을 합니다. 이번에는 30세 이상, 또는 30세 미만이면~ 이라는 조건을 return하여 조건에 맞는 user들을over_30과 under_30이라는 객체에 담았습니다. 결과값 _map 으로 리펙토링!! 12345678910111213141516171819function _map(list, mapper)&#123; var new_list = []; for(var i =0; i &lt; list.length; i++)&#123; new_list.push(mapper(list[i])); &#125; return new_list;&#125;var names = _map(over_30, function(user)&#123; return user.name; &#125;);var ages = _map(under_30, function(user)&#123; return user.age; &#125;);console.log(names);console.log(ages); 우선 _map이라는 함수를 차근차근 살펴봅시다. _map함수는 인자로 list와 mapper를 가지고 list는 _filter의 list인자와 같이 배열이라는 조건만 만족한다면 어떠한 배열이 와도 상관없습니다. mapper 인자는 함수형태이고, i번째 list를 인자로 보내서 i번째 list의 name, 또는 age를 return합니다. 그런 다음, 새롭게 생성되었던 new_list 객체안에 조건을 만족하는 list의 name또는 age가 담기게 됩니다. 최종적으로, 그 new_list를 리턴하면서 이 함수의 역할은 끝나게 됩니다. 우리는 위에서 걸러진 list인 over_30과 under_30을 list인자로 보내야 합니다. 그리고 mapper인자로 조건에 만족하는 list의 name을 리턴하는 것을 보내서 names라는 객체에 담아 콘솔로 확인합니다. (age의 경우도 같습니다.) 결과값 _filter함수는 그 자체로 함수이기때문에 위처럼 꼭 user들을 거르는것이외에도 다른 작업에서 사용될 수 있습니다.이 함수를 사용하기위해선 인자값의 형태를 배열값으로 지켜주면서, predi부분은 순수함수를 만족하는 인자를 넘겨주면 됩니다.... 다음 포스팅에서는 each함수를 통해서 for문 중복을 제거해보도록 하겠습니다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://dlalswjd95-mis.github.io/categories/Javascript/"}],"tags":[{"name":"javascript, FR, map, filter,  programming","slug":"javascript-FR-map-filter-programming","permalink":"http://dlalswjd95-mis.github.io/tags/javascript-FR-map-filter-programming/"}]},{"title":"함수형 프로그래밍의 정의 - part 1","slug":"함수형-프로그래밍","date":"2018-06-22T13:39:56.000Z","updated":"2018-06-29T11:00:38.773Z","comments":true,"path":"2018/06/22/함수형-프로그래밍/","link":"","permalink":"http://dlalswjd95-mis.github.io/2018/06/22/함수형-프로그래밍/","excerpt":"","text":"그동안 나는 자바스크립트를 객체지향프로그래밍으로 배워왔다.그런데 최근 inflearn에서 유인동 강사님의 자바스크립트강좌를 보고 함수형 프로그래밍의 중요성을 깨닫게 되었고,꼭 내가 앞으로 성공적인 프로그래밍을 하기 위해서 제대로 배워야 겠다는 욕심이 생겼다.이번에 새로 hexo를 통해 개발공부관련 블로그를 파보았는데 어떤 글부터 써야 할지 고민했었다.고민 끝에 자바스크립트를 통해 배우는 함수형 프로그래밍을 첫 포스팅주제로 결정하였다! ... 객체지향이랑 뭐가 다른데?123456789101112/* 데이터(객체)기준 */ duck.moveLeft();duck.moveRight();dog.moveLeft();dog.moveRight();/* 함수 기준 */ moveLeft(dog);moveRight(duck);moveLeft(&#123; x: 5, y: 2&#125;);moveRight(dog); 위의 소스를 보면, 위가 객체지향이고, 아래가 함수형언어입니다. 즉, 객체지향은 객체를 기준으로 하는 프로그래밍으로, 데이터(객체)를 먼저 디자인하고 그 데이터에 맞는 메소드를 만드는 식. 함수형은 먼저 함수를 만들고 그 함수에 맞게 데이터 set를 구성하는 식! 객체지향에선 클래스, object, 객체가 일급객체가 되는 반면, 함수형에선 함수자체가 일급객체가 됩니다. 일급객체라는 것은 변수나 데이터 구조(자료구조)안에 담을 수 있다. 파라미터로 전달할 수 있다. 반환값으로 사용할 수 있다. 할당에 사용된 이름과 관계없이 고유한 구별이 가능하다. 위의 조건을 모두 만족해야 한다. 요즘에는 프로그래밍 기법으로 객체지향보다는 함수형을 선호합니다. 요즘 어플리케이션은 대부분 실시간적인 성격이 강해서 전세계에 있는 많은 사람들이 동시에 접속할 수 있도록 해야합니다. 즉, 비동기작업이 문제없이 이뤄져야 하는데요. 그래서 앞으로 개발자들에게 이러한 성격을 가진 어플리케이션을 성공적으로 개발할 수있는 능력이 필요할 거에요. 그러기 위해서 다양한 도구와 개념을 익혀야 하는데 그 중 하나가 함수형 프로그래밍 기술이라고 할 수 있겠습니다.. 그외에도 개발자들이 알아야할 도구들이 점점 많아지고 있는 추세입니다. 개발자 길을 택했다면 당연히 감수해야할 부분이라고 할 수 있겠어요!!^^^^ .. 서론이 너무 길었네요. 자, 그럼 본격적으로 왜 함수형프로그래밍이 뭔지 알아보도록 합시다! 렛츠고! ♬ . . . . 함수형 프로그래밍의 정의.. 함수형 프로그래밍은 성공적인 프로그래밍을 위해 부수 효과를 최소화하고 조합성을 강조하는 프로그래밍 패러다임이다. . . 여기서 부수효과를 최소화한다는 것은 순수함수를 만든다는 것. 순수함수는 들어온 인자가 같으면 항상 동일한 결과를 리턴하는 함수입니다. 함수가 받은 인자 외에 다른 외부상태에 영향을 끼치지도 받지도 않아야 하구요. 또한 리턴값 외에는 외부와 소통하는 것이 없는 함수를 말합니다. 순수함수로만 만들어지면 오류를 줄이고 안정성을 높일 수 있습니다. 조합성을 강조한다는 것은 모듈화 수준을 높인다는 것으로, 순수함수로 모듈화수준을 높이게 되면 생산성이 높은 프로그래밍을 할 수 있습니다. 결론적으로, 생산성이 높은 프로그래밍의 척도는 얼마나 모듈화 수준이 높느냐가 될 수 있겠습니다. 자바스크립트에서도 이러한 함수형 사고 방식으로 프로그래밍하는 것이 가능합니다. 순수 함수란? 쉽게 add라는 함수를 통해 설명하겠습니다. 12345678/* 순수 함수 */function add(a, b)&#123; return a + b;&#125;console.log(add(10,5)); //동일한 인자를 넣으면 동일한 결과를 내보냄.console.log(add(10,5)); //그리고 또다른 특징은 평가시점이 중요하지않다는것이다.console.log(add(10,5)); // 즉, 어느시점에서건 똑같은결과를 가진다. add함수는 a와 b라는 인자를 받아 a+b라는 리턴값을 내보냅니다. 이처럼 순수함수의 중요한 특징은 동일한 인자를 넣으면 동일한 결과를 내보낸다는 것입니다. 그리고 어느시점에서건 똑같은 결과를 내보냅니다. add(10,5)는 어느시점에서건 15라는 결과값을 내보낼 것입니다. 순수함수가 아닌 경우들 12345678910111213//순수함수가 아닌경우 1var c = 10;function add2(a, b)&#123; return a + b + c;&#125;console.log(add2(10,2)); //22console.log(add2(10,3));console.log(add2(10,4));c= 20;console.log(add2(10,2)); //32console.log(add2(10,3));console.log(add2(10,4)); add2라는 함수는 a와 b를 인자로 받아 a + b + c를 결과값으로 내보냅니다.여기서 만약 c가 변하지 않는 상수값이라면 add2함수는 순수함수이겠지만위처럼 중간에 값이 바뀌면 add2의 리턴값도 바뀌게 됩니다. 즉 순수함수조건에 만족하지 못합니다. 12345678//순수함수가 아닌경우 2var c = 20;function add3(a,b)&#123; c = b; return a + b;&#125;console.log(add3(20, 30)); console.log(add3(20, 30)); add3라는 함수는 a와 b라는 인자를 받아와 변수 c에 b값을 할당하고, 리턴값으로 a+b를 내보냅니다. 외부의 값에 영향을 주게 된다면 이 역시 순수함수가 될 수 없습니다. 12345678910//순수함수가 아닌경우 3var obj1 = &#123;val : 10&#125;;function add4(obj, b)&#123; obj.val += b;&#125;console.log(obj1.val); //10add4(obj1, 20);console.log(obj1.val); //30 이번에는 obj1이라는 변수를 선언하고, 이는 val속성값으로 10을 가집니다.add4라는 함수는 obj와 b라는 인자를 받아와서 obj의 val값에 인자 b의 값을 더해 값에 변화를 줍니다.console.log(obj1.val);를 하면 obj1의 val값은 10이니까 콘솔에 10이 뜨게됩니다.하지만 add4(obj1, 20);을 하는순간 obj1의 val값은 10에 20이 더해져 30이 되고,이 시점 이후에console.log(obj1.val);은 30으로 바뀝니다.평가시점이 언제건 상관없이 동일한 값을 넣으면 동일한 값을 내보내야 하는 순수함수의 조건에 만족하지 못하는 것입니다. 그렇다면 3번째 경우를 순수함수로 구현해보겠습니다.12345678910//순수 함수인 경우var obj1 = &#123;val: 10&#125;function add5(obj, b)&#123; return &#123;val: obj.val + b&#125;&#125;console.log(obj1.val); //10var obj2 = add5(obj1, 20); //30console.log(obj1.val); //10console.log(obj2.val); //30 이번에도 위랑 똑같이 obj1이라는 변수를 선언하고, val값으로 10을 주었습니다.add5는 obj와 b를 인자로 받고 val값을 obj의 val값에 b를 더한 값으로 바꿉니다.이 경우, add5(obj1, 20);를 해서 obj1의 val값인 10을 불러와 인자 b값인 20을 더한 30이라는 값을 val값으로 설정합니다.그리고 obj2라는 새로운 변수를 선언하고 {val : 30}을 할당합니다.그러면 console.log(obj1.val);은 어느 시점에서건 10이라는 똑같은 값을 리턴하고console.log(obj2.val);도 마찬가지로 30이라는 값에 변화가 없게 됩니다. 함수형 프로그래밍에서 빠질 수 없는 개념인 순수함수에 대해 배워보았어요.이번에는 순수함수와 함께 아주 중요한 개념인 일급함수에 대해 알아봅시다:) 일급 함수란?이번에도 이해를 돕기 위해 예제를 통해 공부해 봅시다. 1234567891011121314151617/* 일급 함수 */var f1 = function(a)&#123; return a*a;&#125;;cosole.log(f1);function f2(f)&#123; return f();&#125;console.log(f2(function()&#123; return 10;&#125;)); //10console.log(f2(function() &#123; return 20;&#125;)); //20 일급함수는 함수를 변화시켜서 값으로 다룰 수 있다는 것을 의미합니다.그리고 원하는 시점에서 들고 다닐 수 있고, 원하는 시점에 평가할 수도 있는것을 말합니다. 위에서 console.log(f1)을 하면 콘솔창에 function(a){return a*a};가 뜨게 됩니다. 이처럼 변수에 함수를 담을 수 있습니다. 함수 f2는 인자 f를 받아 f()를 리턴합니다. 이때 f에 function(){ return 10; }라는 함수를 담아 호출하면 10이라는 값을 리턴합니다.f2는 그대로입니다. 하지만 다른 값을 return하고 싶을때 그때그때마다 다른 인자값을 주어 함수를 호출하고 값을 리턴하는 방식입니다.그니까.. 가만히 있는 함수를 필요할때 원하는 시점에 불러와 결과값을 얻는 것입니다. 첫 포스팅이 끝났어요 !!일급함수는 순수함수랑 특징이 많이 겹치는데요. 이제 함수를 변수에 담느냐 마느냐에 따라 일급함수이냐 아니냐를 판단할 수 있어요.굳이 두가지 개념을 분리시킬 필요는 없어보여요. 하하그냥 ‘함수형 프로그래밍에선 객체지향이 아니라 일급함수!!, 순수함수!!처럼 함수지향적인 프로그래밍이다~ ‘라고만 이해하면 될것같습니다. 다음 포스팅은 map, filter를 함수형 프로그래밍으로 학습해 볼거에요ㅎㅎㅎ","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://dlalswjd95-mis.github.io/categories/Javascript/"}],"tags":[{"name":"javascript, FR","slug":"javascript-FR","permalink":"http://dlalswjd95-mis.github.io/tags/javascript-FR/"}]}]}