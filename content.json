{"meta":{"title":"Dominoly's IT Blog","subtitle":null,"description":null,"author":"Minjeong Lee","url":"http://dlalswjd95-mis.github.io"},"pages":[],"posts":[{"title":"함수형으로 전환하기(_filter, _map)- part 2","slug":"함수형으로전환하기","date":"2018-06-28T13:39:56.000Z","updated":"2018-07-02T08:51:45.498Z","comments":true,"path":"2018/06/28/함수형으로전환하기/","link":"","permalink":"http://dlalswjd95-mis.github.io/2018/06/28/함수형으로전환하기/","excerpt":"","text":"이번에는 아래와같은 문제를 명령형 프로그래밍코드로 해결한 뒤 , 함수형 프로그래밍으로 refactoring 하도록 하겠습니다. 12345678910var users = [ &#123;id:1, name: 'ID', age:36&#125;, &#123;id:2, name: 'BJ', age:32&#125;, &#123;id:3, name: 'JM', age:32&#125;, &#123;id:4, name: 'PJ', age:27&#125;, &#123;id:5, name: 'HA', age:25&#125;, &#123;id:6, name: 'JE', age:26&#125;, &#123;id:7, name: 'JI', age:31&#125;, &#123;id:8, name: 'MP', age:23&#125; ]; users라는 배열이 존재합니다. json표기법을 따르고 있네요..ㅎㅎ 이 배열은 id, name, age를 가지는 8개의 객체를 포함합니다. 위의 배열로 4가지 문제를 해결해 봅시다. 나이가 30세 이상인 user를 거른다. 걸러진 user들의 name을 수집한다. 나이가 30세 미만인 user를 거른다. 걸러진 user들의 age를 수집한다. 나이가 30세 이상인 user를 거른다. 1234567 var user_over30 =[];for(var i=0; i&lt; users.length; i++)&#123; if(users[i].age &gt;= 30)&#123; user_over30.push(users[i]); &#125;&#125;console.log(user_over30); user_over30이라는 빈 배열을 생성하고, for문으로 users배열 객체하나하나의 나이를 체크하여 30이 넘는 객체를 배열 user_over30 에 담아 콘솔창으로 확인합니다. 결과값30세 이상인 user만 제대로 걸러냈습니다. 걸러진 user들의 name을 수집한다. 12345var names = [];for(var i =0 ; i&lt; user_over30.length ; i++)&#123; names.push(user_over30[i].name);&#125;console.log(names); 이번에는 30세 이상인 user들의 name이 담길 names라는 배열을 새롭게 생성합니다. 그리고 for문을 돌려 i번째 user_over30의 이름을 하나씩 배열에 담습니다. 결과값30세 이상인 user이 name을 수집했습니다. 나이가 30세 미만인 user를 거른다. 걸러진 user들의 age를 수집한다. 123456789101112131415//3. 30세 미만인 users를 거른다. var users_under30 = []; for(var i=0; i &lt;users.length; i++)&#123; if(users[i].age &lt; 30)&#123; users_under30.push(users[i]); &#125; &#125; console.log(users_under30 ); //4. 30세 미만인 users의 ages를 수집한다. var ages = []; for(var i =0; i &lt; users_under30.length; i++)&#123; ages.push(users_under30[i].age) &#125; console.log(ages); 이번은 위의 1번 2번에서 나이 조건을 30세 미만으로 바꾸기만 하면 됩니다. 결과값30세 미만인 user와 그들의 age를 제대로 가져왔습니다. ... 지금까지는 명령형 코드로 프로그래밍했습니다.이제 함수형으로 전환하여 중복코드를 제거하고좀 더 다형적이며 활용성 높은 코드로 바꿔보도록 합시다!!!... 먼저 30세이상인 코드와 미만인 코드의 중복을 줄이고 싶네요.. 함수형프로그래밍에서 쉽게 줄일수있습니다^^ 이 문제는 filter라는 함수를 통해 가능하답니다. _filter 로 리펙토링!! filter라는 순수함수를 새롭게 생성하고 그냥 외부에서 변수를 받아와 필요한 시점에서만 사용되도록 만드는 것… 12345678910111213141516function _filter(list, predi)&#123; //여러번 사용할것을 감안해 users--&gt; list로 바꾸는것이좋음. var new_list = []; // 위처럼 여러번 사용될 것이기 때문에 user_over30, user_under30 --&gt; new_list로 바꾸는게 좋아요.. for(var i=0; i &lt; users.length; i++)&#123; if(predi(users[i])) &#123; //predi는 i번째 users라는 인자값을 받아 user.age &gt;= 30 라는 new_list.push(users[i]); &#125; &#125; return new_list;&#125; var over_30 = _filter(users, function(user)&#123;return user.age &gt;= 30;&#125;); console.log(over_30); var under_30 = _filter(users, function(user)&#123;return user.age &lt; 30 ;&#125;); console.log(under_30); _filter라는 함수는 list, predi라는 인자를 받습니다.list, 즉 array 타입으로된 어떤 배열이 와도 됩니다. predi는 함수이고,어떠한 판별 조건을 리턴해주는 역할을 합니다. 이번에는 30세 이상, 또는 30세 미만이면~ 이라는 조건을 return하여 조건에 맞는 user들을over_30과 under_30이라는 객체에 담았습니다. 결과값 _map 으로 리펙토링!! 12345678910111213141516171819function _map(list, mapper)&#123; var new_list = []; for(var i =0; i &lt; list.length; i++)&#123; new_list.push(mapper(list[i])); &#125; return new_list;&#125;var names = _map(over_30, function(user)&#123; return user.name; &#125;);var ages = _map(under_30, function(user)&#123; return user.age; &#125;);console.log(names);console.log(ages); 우선 _map이라는 함수를 차근차근 살펴봅시다. _map함수는 인자로 list와 mapper를 가지고 list는 _filter의 list인자와 같이 배열이라는 조건만 만족한다면 어떠한 배열이 와도 상관없습니다. mapper 인자는 함수형태이고, i번째 list를 인자로 보내서 i번째 list의 name, 또는 age를 return합니다. 그런 다음, 새롭게 생성되었던 new_list 객체안에 조건을 만족하는 list의 name또는 age가 담기게 됩니다. 최종적으로, 그 new_list를 리턴하면서 이 함수의 역할은 끝나게 됩니다. 우리는 위에서 걸러진 list인 over_30과 under_30을 list인자로 보내야 합니다. 그리고 mapper인자로 조건에 만족하는 list의 name을 리턴하는 것을 보내서 names라는 객체에 담아 콘솔로 확인합니다. (age의 경우도 같습니다.) 결과값 _filter함수는 그 자체로 함수이기때문에 위처럼 꼭 user들을 거르는것이외에도 다른 작업에서 사용될 수 있습니다.이 함수를 사용하기위해선 인자값의 형태를 배열값으로 지켜주면서, predi부분은 순수함수를 만족하는 인자를 넘겨주면 됩니다.... 다음 포스팅에서는 each함수를 통해서 for문 중복을 제거해보도록 하겠습니다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://dlalswjd95-mis.github.io/categories/Javascript/"}],"tags":[{"name":"javascript, FR, map, filter","slug":"javascript-FR-map-filter","permalink":"http://dlalswjd95-mis.github.io/tags/javascript-FR-map-filter/"}]},{"title":"함수형 프로그래밍의 정의 - part 1","slug":"함수형-프로그래밍","date":"2018-06-22T13:39:56.000Z","updated":"2018-06-29T11:00:38.773Z","comments":true,"path":"2018/06/22/함수형-프로그래밍/","link":"","permalink":"http://dlalswjd95-mis.github.io/2018/06/22/함수형-프로그래밍/","excerpt":"","text":"그동안 나는 자바스크립트를 객체지향프로그래밍으로 배워왔다.그런데 최근 inflearn에서 유인동 강사님의 자바스크립트강좌를 보고 함수형 프로그래밍의 중요성을 깨닫게 되었고,꼭 내가 앞으로 성공적인 프로그래밍을 하기 위해서 제대로 배워야 겠다는 욕심이 생겼다.이번에 새로 hexo를 통해 개발공부관련 블로그를 파보았는데 어떤 글부터 써야 할지 고민했었다.고민 끝에 자바스크립트를 통해 배우는 함수형 프로그래밍을 첫 포스팅주제로 결정하였다! ... 객체지향이랑 뭐가 다른데?123456789101112/* 데이터(객체)기준 */ duck.moveLeft();duck.moveRight();dog.moveLeft();dog.moveRight();/* 함수 기준 */ moveLeft(dog);moveRight(duck);moveLeft(&#123; x: 5, y: 2&#125;);moveRight(dog); 위의 소스를 보면, 위가 객체지향이고, 아래가 함수형언어입니다. 즉, 객체지향은 객체를 기준으로 하는 프로그래밍으로, 데이터(객체)를 먼저 디자인하고 그 데이터에 맞는 메소드를 만드는 식. 함수형은 먼저 함수를 만들고 그 함수에 맞게 데이터 set를 구성하는 식! 객체지향에선 클래스, object, 객체가 일급객체가 되는 반면, 함수형에선 함수자체가 일급객체가 됩니다. 일급객체라는 것은 변수나 데이터 구조(자료구조)안에 담을 수 있다. 파라미터로 전달할 수 있다. 반환값으로 사용할 수 있다. 할당에 사용된 이름과 관계없이 고유한 구별이 가능하다. 위의 조건을 모두 만족해야 한다. 요즘에는 프로그래밍 기법으로 객체지향보다는 함수형을 선호합니다. 요즘 어플리케이션은 대부분 실시간적인 성격이 강해서 전세계에 있는 많은 사람들이 동시에 접속할 수 있도록 해야합니다. 즉, 비동기작업이 문제없이 이뤄져야 하는데요. 그래서 앞으로 개발자들에게 이러한 성격을 가진 어플리케이션을 성공적으로 개발할 수있는 능력이 필요할 거에요. 그러기 위해서 다양한 도구와 개념을 익혀야 하는데 그 중 하나가 함수형 프로그래밍 기술이라고 할 수 있겠습니다.. 그외에도 개발자들이 알아야할 도구들이 점점 많아지고 있는 추세입니다. 개발자 길을 택했다면 당연히 감수해야할 부분이라고 할 수 있겠어요!!^^^^ .. 서론이 너무 길었네요. 자, 그럼 본격적으로 왜 함수형프로그래밍이 뭔지 알아보도록 합시다! 렛츠고! ♬ . . . . 함수형 프로그래밍의 정의.. 함수형 프로그래밍은 성공적인 프로그래밍을 위해 부수 효과를 최소화하고 조합성을 강조하는 프로그래밍 패러다임이다. . . 여기서 부수효과를 최소화한다는 것은 순수함수를 만든다는 것. 순수함수는 들어온 인자가 같으면 항상 동일한 결과를 리턴하는 함수입니다. 함수가 받은 인자 외에 다른 외부상태에 영향을 끼치지도 받지도 않아야 하구요. 또한 리턴값 외에는 외부와 소통하는 것이 없는 함수를 말합니다. 순수함수로만 만들어지면 오류를 줄이고 안정성을 높일 수 있습니다. 조합성을 강조한다는 것은 모듈화 수준을 높인다는 것으로, 순수함수로 모듈화수준을 높이게 되면 생산성이 높은 프로그래밍을 할 수 있습니다. 결론적으로, 생산성이 높은 프로그래밍의 척도는 얼마나 모듈화 수준이 높느냐가 될 수 있겠습니다. 자바스크립트에서도 이러한 함수형 사고 방식으로 프로그래밍하는 것이 가능합니다. 순수 함수란? 쉽게 add라는 함수를 통해 설명하겠습니다. 12345678/* 순수 함수 */function add(a, b)&#123; return a + b;&#125;console.log(add(10,5)); //동일한 인자를 넣으면 동일한 결과를 내보냄.console.log(add(10,5)); //그리고 또다른 특징은 평가시점이 중요하지않다는것이다.console.log(add(10,5)); // 즉, 어느시점에서건 똑같은결과를 가진다. add함수는 a와 b라는 인자를 받아 a+b라는 리턴값을 내보냅니다. 이처럼 순수함수의 중요한 특징은 동일한 인자를 넣으면 동일한 결과를 내보낸다는 것입니다. 그리고 어느시점에서건 똑같은 결과를 내보냅니다. add(10,5)는 어느시점에서건 15라는 결과값을 내보낼 것입니다. 순수함수가 아닌 경우들 12345678910111213//순수함수가 아닌경우 1var c = 10;function add2(a, b)&#123; return a + b + c;&#125;console.log(add2(10,2)); //22console.log(add2(10,3));console.log(add2(10,4));c= 20;console.log(add2(10,2)); //32console.log(add2(10,3));console.log(add2(10,4)); add2라는 함수는 a와 b를 인자로 받아 a + b + c를 결과값으로 내보냅니다.여기서 만약 c가 변하지 않는 상수값이라면 add2함수는 순수함수이겠지만위처럼 중간에 값이 바뀌면 add2의 리턴값도 바뀌게 됩니다. 즉 순수함수조건에 만족하지 못합니다. 12345678//순수함수가 아닌경우 2var c = 20;function add3(a,b)&#123; c = b; return a + b;&#125;console.log(add3(20, 30)); console.log(add3(20, 30)); add3라는 함수는 a와 b라는 인자를 받아와 변수 c에 b값을 할당하고, 리턴값으로 a+b를 내보냅니다. 외부의 값에 영향을 주게 된다면 이 역시 순수함수가 될 수 없습니다. 12345678910//순수함수가 아닌경우 3var obj1 = &#123;val : 10&#125;;function add4(obj, b)&#123; obj.val += b;&#125;console.log(obj1.val); //10add4(obj1, 20);console.log(obj1.val); //30 이번에는 obj1이라는 변수를 선언하고, 이는 val속성값으로 10을 가집니다.add4라는 함수는 obj와 b라는 인자를 받아와서 obj의 val값에 인자 b의 값을 더해 값에 변화를 줍니다.console.log(obj1.val);를 하면 obj1의 val값은 10이니까 콘솔에 10이 뜨게됩니다.하지만 add4(obj1, 20);을 하는순간 obj1의 val값은 10에 20이 더해져 30이 되고,이 시점 이후에console.log(obj1.val);은 30으로 바뀝니다.평가시점이 언제건 상관없이 동일한 값을 넣으면 동일한 값을 내보내야 하는 순수함수의 조건에 만족하지 못하는 것입니다. 그렇다면 3번째 경우를 순수함수로 구현해보겠습니다.12345678910//순수 함수인 경우var obj1 = &#123;val: 10&#125;function add5(obj, b)&#123; return &#123;val: obj.val + b&#125;&#125;console.log(obj1.val); //10var obj2 = add5(obj1, 20); //30console.log(obj1.val); //10console.log(obj2.val); //30 이번에도 위랑 똑같이 obj1이라는 변수를 선언하고, val값으로 10을 주었습니다.add5는 obj와 b를 인자로 받고 val값을 obj의 val값에 b를 더한 값으로 바꿉니다.이 경우, add5(obj1, 20);를 해서 obj1의 val값인 10을 불러와 인자 b값인 20을 더한 30이라는 값을 val값으로 설정합니다.그리고 obj2라는 새로운 변수를 선언하고 {val : 30}을 할당합니다.그러면 console.log(obj1.val);은 어느 시점에서건 10이라는 똑같은 값을 리턴하고console.log(obj2.val);도 마찬가지로 30이라는 값에 변화가 없게 됩니다. 함수형 프로그래밍에서 빠질 수 없는 개념인 순수함수에 대해 배워보았어요.이번에는 순수함수와 함께 아주 중요한 개념인 일급함수에 대해 알아봅시다:) 일급 함수란?이번에도 이해를 돕기 위해 예제를 통해 공부해 봅시다. 1234567891011121314151617/* 일급 함수 */var f1 = function(a)&#123; return a*a;&#125;;cosole.log(f1);function f2(f)&#123; return f();&#125;console.log(f2(function()&#123; return 10;&#125;)); //10console.log(f2(function() &#123; return 20;&#125;)); //20 일급함수는 함수를 변화시켜서 값으로 다룰 수 있다는 것을 의미합니다.그리고 원하는 시점에서 들고 다닐 수 있고, 원하는 시점에 평가할 수도 있는것을 말합니다. 위에서 console.log(f1)을 하면 콘솔창에 function(a){return a*a};가 뜨게 됩니다. 이처럼 변수에 함수를 담을 수 있습니다. 함수 f2는 인자 f를 받아 f()를 리턴합니다. 이때 f에 function(){ return 10; }라는 함수를 담아 호출하면 10이라는 값을 리턴합니다.f2는 그대로입니다. 하지만 다른 값을 return하고 싶을때 그때그때마다 다른 인자값을 주어 함수를 호출하고 값을 리턴하는 방식입니다.그니까.. 가만히 있는 함수를 필요할때 원하는 시점에 불러와 결과값을 얻는 것입니다. 첫 포스팅이 끝났어요 !!일급함수는 순수함수랑 특징이 많이 겹치는데요. 이제 함수를 변수에 담느냐 마느냐에 따라 일급함수이냐 아니냐를 판단할 수 있어요.굳이 두가지 개념을 분리시킬 필요는 없어보여요. 하하그냥 ‘함수형 프로그래밍에선 객체지향이 아니라 일급함수!!, 순수함수!!처럼 함수지향적인 프로그래밍이다~ ‘라고만 이해하면 될것같습니다. 다음 포스팅은 map, filter를 함수형 프로그래밍으로 학습해 볼거에요ㅎㅎㅎ","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://dlalswjd95-mis.github.io/categories/Javascript/"}],"tags":[{"name":"javascript, FR","slug":"javascript-FR","permalink":"http://dlalswjd95-mis.github.io/tags/javascript-FR/"}]}]}