{"meta":{"title":"Dominoly's IT Blog","subtitle":null,"description":null,"author":"Minjeong Lee","url":"http://dlalswjd95-mis.github.io"},"pages":[],"posts":[{"title":"_get함수만들기 - part2","slug":"get함수만들기","date":"2018-07-11T11:06:40.000Z","updated":"2018-07-11T11:24:05.773Z","comments":true,"path":"2018/07/11/get함수만들기/","link":"","permalink":"http://dlalswjd95-mis.github.io/2018/07/11/get함수만들기/","excerpt":"","text":"_get이 함수는 object와 원하는 key를 인자로 받아서 object의 key로 접근하여원하는 결과를 리턴합니다. _get함수는 아래와 같습니다 . 123function _get(obj, key)&#123; return obj[key];&#125; 그런데 만약 obj가 null값이거나 undefinde라면 error가 발생할 것입니다._get에 아래와 같이 조건을 추가해서 문제를 해결할 수 있습니다. 123function _get(obj, key)&#123; return obj == null ? undefined : obj[key]; &#125; 자, 만약 users라는 배열의 첫번째 객체의 ‘name’ 값을 얻고 싶다면 아래처럼 접근하면 되겠죠. 123var user1 = users[0]; console.log(user1.name); console.log(_get(user1,'name')); 만약, users에 없는 10번째 유저의 ‘name’값을 호출하게 된다면 error가 날것입니다. 하지만, _get함수를 사용하게 되면 오류가 나지 않고 undefined값을 내보낼 것이기 떄문에에러가 나지 않습니다. 그래서 좀더 안전한 코딩을 할 수 있게 됩니다. 이번엔, _get을 만들때 이전 포스팅에서 학습했던 _curry를 이용해서 이전에 만들어 놓았던 코드를 더 간결하게 만들어보겠습니다. 먼저, _get함수를 아래와 같이 _curryr을 통해서 정의해 보겠습니다. 123var _get = _curryr(function(obj, key)&#123; return obj == null ? undefined : obj[key];&#125;); 그럼 평가순서를 뒤집어서 인자 중에 맨 오른쪽(‘name’)부터 적용할 수 있습니다. 1console.log(_get('name')(user1)); 이런식으로, name을 먼저꺼내고, 그 다음 user1을 꺼낼 수 있습니다. 즉, _get(‘name’) 이것 자체가 name을 꺼내는 함수가 됩니다. 1var get_name = _get('name'); get_name 이라는 함수객체를 생성할 수 있겠네요. 만약, get_name이라는 함수에 user1을 넣으면 name값을 확인해 볼 수 있습니다. 기존에 만들었던 코드를 불러와 _get함수를 적용해 보겠습니다. 123456789console.log( _map( _filter(users, function(user)&#123;return user.age &gt;= 30;&#125;), function(user)&#123;return user.name;&#125;)); console.log( _map( _filter(users, function(user)&#123;return user.age &lt; 30;&#125;), function(user)&#123;return user.age;&#125;)); 위의 코드에서 function(user){return user.name;} 이부분을 _get(‘name’)으로 바꿔주기만 하면 됩니다. 그럼, 아래처럼 훨씬 간결하게 코드를 짤 수 있습니다. 12345console.log( _map(_filter(users, function(user)&#123;return user.age &gt;= 30;&#125;), _get('name')));console.log( _map(_filter(users, function(user)&#123;return user.age &lt; 30;&#125;), _get('age'))); 간단하게 커링에 이어서 get함수에 대해서 공부해보았는데요.지금까지 배운 강의중에 제일 이해하기 어려웠던 부분이었던 것 같네요.. 하지만, 이정도로 포기하지 않습니다^^하하 다음 강의는 reduce라는 함수에 대한 것이네요. 화이팅입니다 !!","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://dlalswjd95-mis.github.io/categories/Javascript/"}],"tags":[{"name":"_get, get, javascript, programming, 함수형프로그래밍","slug":"get-get-javascript-programming-함수형프로그래밍","permalink":"http://dlalswjd95-mis.github.io/tags/get-get-javascript-programming-함수형프로그래밍/"}]},{"title":"커링함수만들기(_curry,_curryr)-part2","slug":"커링함수만들기-curry-curryr","date":"2018-07-11T09:47:24.000Z","updated":"2018-07-11T11:01:16.409Z","comments":true,"path":"2018/07/11/커링함수만들기-curry-curryr/","link":"","permalink":"http://dlalswjd95-mis.github.io/2018/07/11/커링함수만들기-curry-curryr/","excerpt":"","text":"커링(Curry) 커링이란 다중 인수 (혹은 여러 인수의 튜플)을 갖는 함수를 단일 인수를 갖는 함수들의 함수열로 바꾸는 것을 말한다. 한마디로, 함수에 인자를 하나씩 적용해 나가다가 필요한 인자가 모두 채워지면 함수 본체를 실행하는 기법입니다. 자바스크립트에서는 커링기법이 지원되지 않지만 앞에 포스팅에서 다뤘듯이 자바스크립트는 일급함수가 지원되고, 얼마든지 평가시점을 마음대로 다룰 수 있기 때문에 커링과 같은 기법을 구현할 수 있습니다. 커링함수는 다음과 같습니다. 1234567function _curry(fn)&#123; return function(a)&#123; return function(b)&#123; return fn(a, b); &#125; &#125; &#125; 커링은 인자로 함수(fn)를 받고, 커링함수를 실행하는 즉시 안쪽함수가 리턴됩니다. 그리고 a라는 인자를 받은 뒤 또 b를 인자로 받는 함수가 리턴됩니다. b를 인자로 받으면 fn(a,b)이라는 본체함수가 실행됩니다. 만약 인자 두개를 받아서 더하는 add함수를 만든다고 하면 일반적으로 아래와 같이 만듭니다. 1234var add= function(a, b)&#123; return a+b; &#125;; console.log(add(10,5)); 결과값으로 15라는 결과를 얻겠죠. 커리함수같은 경우에, add함수를 만들때 아래처럼 _curry로 감싸주기만하면add함수는 커링이 되는 함수로 구현됩니다. 123var add= _curry(function(a, b)&#123; return a+b; &#125;); 함수가 동작하는 순서는 다음과 같습니다. add라는 함수를 만들때 _curry로 감쌉니다. add라는 함수는 fn이 됩니다. add함수는 return fn(a, b); 이곳에 위치하게된다. 123456789101112function(a)&#123; return function(b)&#123; return fn(a, b); &#125; ``` 이 부분이 제일 처음 호출된다. 다시말해, ```jsvar add = function(a)&#123; return function(b)&#123; return fn(a, b); &#125; 위처럼 된다고 볼수있겠다. 인자 a를 먼저 받고, 그 다음에 b를 받은 다음에, 처음에 받아두었던 fn이 나중에 실행된다. 아래 예제를 통해 이해를 도와봅시다ㅎㅎ 결과값 맞춰보기12var add10 = add(10);console.log(add10(5)); 결과값은?? 10+5인 15가 됩니다. 동작순서는 다음과 같습니다. 먼저 인자 10을 받은 add함수의 리턴값이 add10이라는 객체로 들어갑니다. 1234var add10 = function(10)&#123; return function(b)&#123; return fn(a, b); &#125; add10 이라는 함수에 인자 5가 들어갑니다. 그리고, add10이 실행되는 즉시 1234567891011function(b)&#123; return fn(a, b); &#125;``` 이부분이 실행됩니다. 인자 b에 5가 들어가구요. 3. 그럼 본체함수인 fn(a,b)가 실행됩니다. ```jsfunction(a, b)&#123; return a+b; &#125; 바로 이부분이 fn이었죠.그래서 a에는 10, b에는 5가 차례대로 모두 받아졌을때본체함수가 실행되어 5 + 10 인 15라는 결과값을 얻게됩니다. 그래서 ,12console.log(add(5)(3)); //1console.log(add(10)(3)); //2 1번은 결과가 8이되고2번은 13이 됩니다. ‘‘‘ 결국은, 본체함수인123function(a, b)&#123; return a+b; &#125; 이 부분을 값으로 들고있다가 나중에 원하는 시점에 최종적으로 평가하는 기법입니다. 계속해서 이러한 기법을 통해서.함수가 함수를 대신 실행하거나, 함수가 함수를 리턴하면서함수를 조합해 나가는 것이 바로 함수형 프로그래밍입니다. _curry는 함수형 프로그래밍의 응용사례를 잘 보여주고 있습니다._curry함수로 적용했을 때에는 함수로 인자를 하나만 적용하게 되면 함수를 리턴하게 됩니다. 하지만 위의 방식으로는console.log(add(1,2));이것의 결과값은 3이 아니라 함수를 리턴하게 됩니다. 그 이유는 123function(b)&#123; return fn(a, b);&#125; 위의 함수를 리턴하는 것에서 그치기 때문입니다.만약 커리함수를 위처럼 인자두개가 들어오면 함수를 리턴하지 않고즉시 값을 도출하게끔 만들려면 조건문을 추가합니다. 12345678function _curry(fn)&#123; return function(a,b)&#123; if(agument.length == 2) return fn(a, b); return function(b)&#123; return fn(a, b); &#125; &#125; &#125; 위처럼 조건문을 통해서 인자값이 2개면 본체함수를 실행하도록 만들수 있습니다. 하지만 저기에도 return을 두번한다는 문제가 있어요.그래서 그걸 해결하기 위해 아래처럼 수정합니다. 12345function _curry(fn)&#123; return function(a,b)&#123; return agument.length == 2 ? fn(a, b) : function(b)&#123; return fn(a, b);&#125;; &#125; &#125; 이번에는 인자 두개를 받아서 빼기를 하는 함수를 구현해보겠습니다. 12345 var sub = _curry(function(a,b)&#123; return a - b; &#125;);console.log(sub(10, 5)); 결과값은 5가 되겠죠. 더 나아가서12var sub10 = sub(10); console.log(sub10(5)); 위를 실행하면, 5가 됩니다. 하지만 , 표현이 좋지만은 않습니다. sub10이라는 객체에 sub(10)이라는 함수가 들어오고sub10(5)라는 것은 sub(10)함수안에 5가 들어간 것이라고 볼 수 있습니다. 그렇게 되면, 들어오는 인자인 5에 sub10이라는 함수를 적용하는것이니까5-10이 되어야 좀 더 자연스러운 표현같지 않나요…?12console.log(sub(10, 5)); //1console.log(sub10(5)); //2 1번경우는 10-5가 자연스럽지만, 2번은 5에 10을 빼는 것처럼 표현되죠. 그래서 표현을 좀더 자연스럽게 하기위해서 원래 같은 경우 _curry는 왼쪽에서 부터 인자를 적용해나가는데, 새롭게 _curryr이라는 함수를 생성해서 오른쪽에서부터 인자를 적용해나가도록 할 수 있습니다. _curry뿐만아니라 다른 함수에서도 자연스러운 표현을 위해서 뒤에 r이라고 많이 붙인다고 해요. r은 right를 의미하겠죠!하하 _curryr은 _curry와 같은 동작을 하지만 단지, 오른쪽에서부터 인자를 적용해 나간다~ 는 점만 다를 뿐입니다!! _curryr은 다음과 같습니다. 12345function _curryr(fn)&#123; return function(a, b) &#123; return agument.length == 2 ? fn(a, b) : function(b)&#123; return fn(b, a);&#125;; &#125; &#125; 인자값이 2개일 때는 아까처럼 순서대로 적용하지만,인자가 1개인 경우에는 return fn(b, a); 이런 식으로 a와 b의 순서를 바꿔두번째 인자에서 처음에 들어왔던 인자를 빼도록 합니다. 그럼 위의 2번은 5 - 10 인 -5가 리턴됩니다. 지금까지 커링기법에 대해서 알아봤어요. 다음 포스팅은 원하는 값을 얻어오는 _get함수에 대해서 다룰게요ㅎㅎ","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://dlalswjd95-mis.github.io/categories/Javascript/"}],"tags":[{"name":"javascript, _curry, _curryr, programming","slug":"javascript-curry-curryr-programming","permalink":"http://dlalswjd95-mis.github.io/tags/javascript-curry-curryr-programming/"}]},{"title":"오라클 Intro (user생성 및 테이블작성)","slug":"오라클intro","date":"2018-07-08T05:39:26.000Z","updated":"2018-07-08T06:41:10.607Z","comments":true,"path":"2018/07/08/오라클intro/","link":"","permalink":"http://dlalswjd95-mis.github.io/2018/07/08/오라클intro/","excerpt":"","text":"Oracle Intro가장 먼저 (ctrl + R) 후, cmd 입력해서 콘솔창을 엽니다. frontspace라는 DBF 파일을 생성합니다. 오라클에서는 tablespace라는 큰 개념을 이용합니다. 12345SQL&gt; create tablespace frontspace 2 datafile &apos;C:\\oraclexe\\app\\oracle\\oradata\\XE\\frontspace.dbf&apos; 3 size 2M;Tablespace created. frontspace라는 db를 생성합니다. 개발자를 위한 새로운 user를 생성합니다.123456SQL&gt; create user dominonly 2 identified by 1234 3 default tablespace frontspace 4 quota unlimited on frontspace;User created. db를 관리하는 dba가 아닌 개발자는 database를 건드릴 수 있는 권한이 없기 때문에 관리자로부터 권한을 받아내야 합니다. 그러기 위해서는 db에 새로운 자신의 계정을 생성한 뒤에, dba로부터 권한을 받아야 합니다. 실제 실무에서 db를 건드려야 하는 상황이 왔을때, 함부로 db password나 name을 요구하면 스파이로 오해받을 수 있습니다^^;;; 저같은 경우 계정명-&gt; dominonly, 패스워드-&gt; 1234로 설정하였습니다. db를 생성할때 default로 입력될 tablespace를 위에서 만들었던 frontspace로 셋팅합니다. 수정은 ed 라는 편집기로 가능합니다(여기서는 ;이 아니라 /로 문장이 끝났음을 알려줍니다.) 생성된 유저를 확인해봅니다.123456789SQL&gt; run 1 create user dominonly 2 identified by 1234 3 default tablespace frontspace 4* quota unlimited on frontspacecreate user front *ERROR at line 1:ORA-01920: user name &apos;FRONT&apos; conflicts with another user or role name 새로운 cmd창을 열어 생생된 user로 접속해봅니다.123456789C:\\Users\\Leeminjeong&gt;sqlplusSQL*Plus: Release 11.2.0.2.0 Production on 토 7월 7 09:56:08 2018Copyright (c) 1982, 2014, Oracle. All rights reserved.Enter user-name: front/frontERROR:ORA-01045: user FRONT lacks CREATE SESSION privilege; logon denied 접속권한 오류가 뜨는 것을 확인할 수 있습니다. 다시 이전 cmd창으로 와서 생성한 계정에 권한을 부여합니다.123SQL&gt; grant create session to dominonly;Grant succeeded. 두번째 cmd창에서 접속된 것을 확인해 볼 수 있습니다.1234Enter user-name: dominonly/1234Connected to:Oracle Database 11g Express Edition Release 11.2.0.2.0 - 64bit Production 첫번째 cmd에서 user에게 table을 만드는 권한도 부여합니다.123SQL&gt; grant create table to dominonly;Grant succeeded. table을 만듭니다.저는 fruit의 정보를 담은 table을 생성해 보았습니다. 12345678SQL&gt; run 1 create table fruit( 2 name varchar(20) 3 , price number default 0 4 , loc varchar(30) 5* )Table created. 이제 table의 데이터를 생성합니다.12345678910111213141516171819SQL&gt; insert into fruit(name,price,loc) values(&apos;배&apos;,2000,&apos;나주&apos;);1 row created.SQL&gt; insert into fruit(name,price,loc) values(&apos;사과&apos;,1000,&apos;대구&apos;);1 row created.SQL&gt; insert into fruit(name,price,loc) values(&apos;참외&apos;,1500,&apos;성주&apos;);1 row created.SQL&gt; insert into fruit(name,price,loc) values(&apos;바나나&apos;,3000,&apos;필리핀&apos;);1 row created.SQL&gt; insert into fruit(name,price,loc) values(&apos;딸기&apos;,4000,&apos;이마트&apos;);1 row created. 5개의 데이터를 담아보았습니다.여기서 중요한데, commit이라는 과정을 꼭 거쳐야지만 입력된 데이터를확정시킬 수 있습니다. commit을 하지 않으면 애써 입력한 데이터들을 모두잃을 수 있으니까 유의해야합니다. Commit 해서 확정시킵니다.1234SQL&gt; commit;Commit complete. table을 확인해봅니다.12345678910SQL&gt; select * from fruit;NAME PRICE LOC---------------------------------------- ---------- ------------------------------------------------------------배 2000 나주사과 1000 대구참외 1500 성주바나나 3000 필리핀딸기 4000 이마트 만약 table의 가로길이를 조절하고 싶다면SQL&gt; set line 300; 라고 입력하면 됩니다. oracle나가기!!12SQL&gt; exitDisconnected from Oracle Database 11g Express Edition Release 11.2.0.2.0 - 64bit Production 간단하게 exit이라고 입력하면 나갈수있습니다.","categories":[{"name":"oracle","slug":"oracle","permalink":"http://dlalswjd95-mis.github.io/categories/oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://dlalswjd95-mis.github.io/tags/oracle/"}]},{"title":"다형성-part2","slug":"다형성","date":"2018-07-02T10:37:15.000Z","updated":"2018-07-10T06:23:11.470Z","comments":true,"path":"2018/07/02/다형성/","link":"","permalink":"http://dlalswjd95-mis.github.io/2018/07/02/다형성/","excerpt":"","text":"이번에는 다형성에 대해 알아볼게요! 이미 존재하는 filter, map 메소드우리가 그동안 만들었던 세가지 함수(_filter, _each, _map)는 이미 자바스크립트에 존재하는 메소드들입니다. 먼저 _map 함수와 같은 기능을 하는 map이라는 메소드를 살펴보겠습니다.12345console.log( [1,2,3].map(function(val)&#123; return val*2; &#125;) ); map은 Array라는 내장객체에 이미 존재하는 함수입니다.배열에 map이라는 함수를 적용하고, val이라는 값을 받아 배열 순서대로 2를곱하여 결과값을 리턴합니다. 이번에는 filter 메소드를 살펴보겠습니다. 12345console.log( [1,2,3,4].filter(function(val)&#123; return val % 2; &#125;) ); filter함수도 Array 객체안에 이미 존재하는 함수입니다.이번에는 1부터 4까지 배열을 받아 2로 나누어 지지 않는 것들을 차례로 리턴해줍니다. 메소드를 따로 함수로 정의하는 이유 하지만 우리가 그동안 왜 이미있는 것들을 만들었는지 궁금하지 않나요? 그 이유는 이미존재하는 함수는 사실 함수가 아니라 Array객체의 메소드 입니다. 그렇기 떄문에 해당 instance가 아니면 사용할 수 없습니다. 즉, Array가 아닌 객체들에서는 사용할 수 없다는 것이죠. 그래서, 다형성을 지원하기 어려운 부분이 있습니다. 하지만, 함수가 기준이 되는 함수형 프로그래밍에서는 함수를 먼저 만들고, 그 함수에 맞는 데이터을 구성해서 함수에 적용하는 식으로 프로그래밍을 하게 됩니다. 이는 굉장히 유연하고 실용적인 형태라고 볼 수 있겠죠! 그래서 12345console.log( document.querySelectorAll('*').map(function(node)&#123; return node.nodeName; &#125;) ); 위를 실행하게 되면Uncaught TypeError: document.querySelectorAll(…).map is not a function이와같이 map이라는 메소드가 실행되지 않는 것을 볼 수 있습니다. 실제로, 1alert(document.querySelectorAll('*')); 를 해보면 배열과 같은 형태를 갖추고 있는 것을 확인할 수 있습니다. 하지만, 이는 array_like 로 실제 Array객체가 아닌 NodeList라는 프로토타입을 가지는걸 확인하실수있습니다.그렇기 때문에 Array객체의 메소드인 map이 실행되지 않는 다는 뜻이죠. 반면에 , 우리가 만들었던 _map함수를 이용하면12345console.log( _map(document.querySelectorAll('*'), function(node)&#123; return node.nodeName; &#125;) ); 결과값 1// (7) [\"HTML\", \"HEAD\", \"META\", \"TITLE\", \"BODY\", \"SCRIPT\", \"SCRIPT\"] 위와 같이 제대로 된 결과를 얻을 수 있습니다. 외부 다형성과 내부 다형성123_map([1,2,3,4], function(v)&#123; return v + 10; &#125;); 위에서 function(v){return v+10} 부분을 콜백함수라고 부르기도 합니다.함수형프로그래밍에서는 두번째 함수가 어떤 역할을 하는 함수인지에 따라서 다양한 이름을 가지는 것이 중요합니다.콜백함수는 무조건 어떤일을 다~ 수행된 다음에 디시 돌려주는 것을 뜻하는 데요. 이전에 우리가 만들었던 두번째 함수인 predi, iter, mapper 처럼 각각의 역할이 다른 함수들을 다르게 이름짓는 것이 좋습니다이런 두번쨰 함수들을 보조함수라고 부르는데 , _map, _each, _filter가 외부에서 큰 틀을 잡았다면(외부 다형성) , 이 보조함수들은 실제로 개발자가 원하는 일들을 수행시키기 위해 정의하는 부분(내부 다형성)이라고 보면 되겠습니다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://dlalswjd95-mis.github.io/categories/Javascript/"}],"tags":[{"name":"javascript, 다형성, programming","slug":"javascript-다형성-programming","permalink":"http://dlalswjd95-mis.github.io/tags/javascript-다형성-programming/"}]},{"title":"함수형으로전환하기(_each) - part2","slug":"함수형으로전환하기-each함수","date":"2018-07-02T08:55:53.000Z","updated":"2018-07-02T10:35:32.692Z","comments":true,"path":"2018/07/02/함수형으로전환하기-each함수/","link":"","permalink":"http://dlalswjd95-mis.github.io/2018/07/02/함수형으로전환하기-each함수/","excerpt":"","text":"보시면 _filter와 _map함수에서 중복되는 코드를 확인하실 수 있습니다....중복되는 부분 for문(루프) 해당 i번째 list를 참조하는 부분 위의 중복되는 부분을 _each라는 함수로 따로 빼내서 제거할 수 있습니다. 123456function _each(list, iter)&#123; for(var i =0 ; i &lt; list.length; i++) &#123; iter(list[i]); &#125; return list; //없어도 실행되는데 문제는 없음.&#125; 이 _each라는 함수는 인자로 list와 iter를 받아서 반복을 하는 함수입니다.중복되는 for문을 그대로 가져오고, 받은 값을 그대로 리턴합니다. 간단히 말해 _each함수는 for문의 역할을 완전히 위임하는 함수라고 보면 됩니다. 먼저 _filter함수를 _each함수로 리펙토링합니다. 12345678function _filter(list, predi)&#123; var new_list = []; _each(list, function(val)&#123; if(predi(val)) new_list.push(val); &#125;); return new_list;&#125; _each(list, function(val)) –&gt; _each함수에서 list의 특정 i번째 요소를 하나하나씩 꺼내서 iter함수를 실행시킵니다.위에서는 iter함수로 function(val){ if(predi(val)) new_list.push(val);} 를 보냅니다. 특정 i번째 요소들이 val로 들어가고predi라는 조건이 true일때 val값이 new_list에 담겨 리턴됩니다. 그다음 _map함수도 _each함수로 리펙토링합니다. 1234567function _map(list, mapper)&#123; var new_list = []; _each(list, function(val)&#123; new_list.push(mapper(val)); &#125;); return new_list;&#125; _each함수에서 꺼내진 특정 i번쨰 요소들은 mapper에게 보냅니다.여기에서는 mapper가 특정 i번쨰 요소의 name이나 age를 리턴합니다.mapper(val)의 리턴값이 new_list에 담겨지고, 최종적으로 new_list를 리턴합니다. .... 다음 포스팅에서는 다형성에 대해서 배워볼게요!","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://dlalswjd95-mis.github.io/categories/Javascript/"}],"tags":[{"name":"javascript, FR, each, programming","slug":"javascript-FR-each-programming","permalink":"http://dlalswjd95-mis.github.io/tags/javascript-FR-each-programming/"}]},{"title":"함수형으로 전환하기(_filter, _map)- part 2","slug":"함수형으로전환하기","date":"2018-06-28T13:39:56.000Z","updated":"2018-07-02T08:57:57.395Z","comments":true,"path":"2018/06/28/함수형으로전환하기/","link":"","permalink":"http://dlalswjd95-mis.github.io/2018/06/28/함수형으로전환하기/","excerpt":"","text":"이번에는 아래와같은 문제를 명령형 프로그래밍코드로 해결한 뒤 , 함수형 프로그래밍으로 refactoring 하도록 하겠습니다. 12345678910var users = [ &#123;id:1, name: 'ID', age:36&#125;, &#123;id:2, name: 'BJ', age:32&#125;, &#123;id:3, name: 'JM', age:32&#125;, &#123;id:4, name: 'PJ', age:27&#125;, &#123;id:5, name: 'HA', age:25&#125;, &#123;id:6, name: 'JE', age:26&#125;, &#123;id:7, name: 'JI', age:31&#125;, &#123;id:8, name: 'MP', age:23&#125; ]; users라는 배열이 존재합니다. json표기법을 따르고 있네요..ㅎㅎ 이 배열은 id, name, age를 가지는 8개의 객체를 포함합니다. 위의 배열로 4가지 문제를 해결해 봅시다. 나이가 30세 이상인 user를 거른다. 걸러진 user들의 name을 수집한다. 나이가 30세 미만인 user를 거른다. 걸러진 user들의 age를 수집한다. 나이가 30세 이상인 user를 거른다. 1234567 var user_over30 =[];for(var i=0; i&lt; users.length; i++)&#123; if(users[i].age &gt;= 30)&#123; user_over30.push(users[i]); &#125;&#125;console.log(user_over30); user_over30이라는 빈 배열을 생성하고, for문으로 users배열 객체하나하나의 나이를 체크하여 30이 넘는 객체를 배열 user_over30 에 담아 콘솔창으로 확인합니다. 결과값30세 이상인 user만 제대로 걸러냈습니다. 걸러진 user들의 name을 수집한다. 12345var names = [];for(var i =0 ; i&lt; user_over30.length ; i++)&#123; names.push(user_over30[i].name);&#125;console.log(names); 이번에는 30세 이상인 user들의 name이 담길 names라는 배열을 새롭게 생성합니다. 그리고 for문을 돌려 i번째 user_over30의 이름을 하나씩 배열에 담습니다. 결과값30세 이상인 user이 name을 수집했습니다. 나이가 30세 미만인 user를 거른다. 걸러진 user들의 age를 수집한다. 123456789101112131415//3. 30세 미만인 users를 거른다. var users_under30 = []; for(var i=0; i &lt;users.length; i++)&#123; if(users[i].age &lt; 30)&#123; users_under30.push(users[i]); &#125; &#125; console.log(users_under30 ); //4. 30세 미만인 users의 ages를 수집한다. var ages = []; for(var i =0; i &lt; users_under30.length; i++)&#123; ages.push(users_under30[i].age) &#125; console.log(ages); 이번은 위의 1번 2번에서 나이 조건을 30세 미만으로 바꾸기만 하면 됩니다. 결과값30세 미만인 user와 그들의 age를 제대로 가져왔습니다. ... 지금까지는 명령형 코드로 프로그래밍했습니다.이제 함수형으로 전환하여 중복코드를 제거하고좀 더 다형적이며 활용성 높은 코드로 바꿔보도록 합시다!!!... 먼저 30세이상인 코드와 미만인 코드의 중복을 줄이고 싶네요.. 함수형프로그래밍에서 쉽게 줄일수있습니다^^ 이 문제는 filter라는 함수를 통해 가능하답니다. _filter 로 리펙토링!! filter라는 순수함수를 새롭게 생성하고 그냥 외부에서 변수를 받아와 필요한 시점에서만 사용되도록 만드는 것… 12345678910111213141516function _filter(list, predi)&#123; //여러번 사용할것을 감안해 users--&gt; list로 바꾸는것이좋음. var new_list = []; // 위처럼 여러번 사용될 것이기 때문에 user_over30, user_under30 --&gt; new_list로 바꾸는게 좋아요.. for(var i=0; i &lt; users.length; i++)&#123; if(predi(users[i])) &#123; //predi는 i번째 users라는 인자값을 받아 user.age &gt;= 30 라는 new_list.push(users[i]); &#125; &#125; return new_list;&#125; var over_30 = _filter(users, function(user)&#123;return user.age &gt;= 30;&#125;); console.log(over_30); var under_30 = _filter(users, function(user)&#123;return user.age &lt; 30 ;&#125;); console.log(under_30); _filter라는 함수는 list, predi라는 인자를 받습니다.list, 즉 array 타입으로된 어떤 배열이 와도 됩니다. predi는 함수이고,어떠한 판별 조건을 리턴해주는 역할을 합니다. 이번에는 30세 이상, 또는 30세 미만이면~ 이라는 조건을 return하여 조건에 맞는 user들을over_30과 under_30이라는 객체에 담았습니다. 결과값 _map 으로 리펙토링!! 12345678910111213141516171819function _map(list, mapper)&#123; var new_list = []; for(var i =0; i &lt; list.length; i++)&#123; new_list.push(mapper(list[i])); &#125; return new_list;&#125;var names = _map(over_30, function(user)&#123; return user.name; &#125;);var ages = _map(under_30, function(user)&#123; return user.age; &#125;);console.log(names);console.log(ages); 우선 _map이라는 함수를 차근차근 살펴봅시다. _map함수는 인자로 list와 mapper를 가지고 list는 _filter의 list인자와 같이 배열이라는 조건만 만족한다면 어떠한 배열이 와도 상관없습니다. mapper 인자는 함수형태이고, i번째 list를 인자로 보내서 i번째 list의 name, 또는 age를 return합니다. 그런 다음, 새롭게 생성되었던 new_list 객체안에 조건을 만족하는 list의 name또는 age가 담기게 됩니다. 최종적으로, 그 new_list를 리턴하면서 이 함수의 역할은 끝나게 됩니다. 우리는 위에서 걸러진 list인 over_30과 under_30을 list인자로 보내야 합니다. 그리고 mapper인자로 조건에 만족하는 list의 name을 리턴하는 것을 보내서 names라는 객체에 담아 콘솔로 확인합니다. (age의 경우도 같습니다.) 결과값 _filter함수는 그 자체로 함수이기때문에 위처럼 꼭 user들을 거르는것이외에도 다른 작업에서 사용될 수 있습니다.이 함수를 사용하기위해선 인자값의 형태를 배열값으로 지켜주면서, predi부분은 순수함수를 만족하는 인자를 넘겨주면 됩니다.... 다음 포스팅에서는 each함수를 통해서 for문 중복을 제거해보도록 하겠습니다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://dlalswjd95-mis.github.io/categories/Javascript/"}],"tags":[{"name":"javascript, FR, map, filter,  programming","slug":"javascript-FR-map-filter-programming","permalink":"http://dlalswjd95-mis.github.io/tags/javascript-FR-map-filter-programming/"}]},{"title":"함수형 프로그래밍의 정의 - part 1","slug":"함수형-프로그래밍","date":"2018-06-22T13:39:56.000Z","updated":"2018-06-29T11:00:38.773Z","comments":true,"path":"2018/06/22/함수형-프로그래밍/","link":"","permalink":"http://dlalswjd95-mis.github.io/2018/06/22/함수형-프로그래밍/","excerpt":"","text":"그동안 나는 자바스크립트를 객체지향프로그래밍으로 배워왔다.그런데 최근 inflearn에서 유인동 강사님의 자바스크립트강좌를 보고 함수형 프로그래밍의 중요성을 깨닫게 되었고,꼭 내가 앞으로 성공적인 프로그래밍을 하기 위해서 제대로 배워야 겠다는 욕심이 생겼다.이번에 새로 hexo를 통해 개발공부관련 블로그를 파보았는데 어떤 글부터 써야 할지 고민했었다.고민 끝에 자바스크립트를 통해 배우는 함수형 프로그래밍을 첫 포스팅주제로 결정하였다! ... 객체지향이랑 뭐가 다른데?123456789101112/* 데이터(객체)기준 */ duck.moveLeft();duck.moveRight();dog.moveLeft();dog.moveRight();/* 함수 기준 */ moveLeft(dog);moveRight(duck);moveLeft(&#123; x: 5, y: 2&#125;);moveRight(dog); 위의 소스를 보면, 위가 객체지향이고, 아래가 함수형언어입니다. 즉, 객체지향은 객체를 기준으로 하는 프로그래밍으로, 데이터(객체)를 먼저 디자인하고 그 데이터에 맞는 메소드를 만드는 식. 함수형은 먼저 함수를 만들고 그 함수에 맞게 데이터 set를 구성하는 식! 객체지향에선 클래스, object, 객체가 일급객체가 되는 반면, 함수형에선 함수자체가 일급객체가 됩니다. 일급객체라는 것은 변수나 데이터 구조(자료구조)안에 담을 수 있다. 파라미터로 전달할 수 있다. 반환값으로 사용할 수 있다. 할당에 사용된 이름과 관계없이 고유한 구별이 가능하다. 위의 조건을 모두 만족해야 한다. 요즘에는 프로그래밍 기법으로 객체지향보다는 함수형을 선호합니다. 요즘 어플리케이션은 대부분 실시간적인 성격이 강해서 전세계에 있는 많은 사람들이 동시에 접속할 수 있도록 해야합니다. 즉, 비동기작업이 문제없이 이뤄져야 하는데요. 그래서 앞으로 개발자들에게 이러한 성격을 가진 어플리케이션을 성공적으로 개발할 수있는 능력이 필요할 거에요. 그러기 위해서 다양한 도구와 개념을 익혀야 하는데 그 중 하나가 함수형 프로그래밍 기술이라고 할 수 있겠습니다.. 그외에도 개발자들이 알아야할 도구들이 점점 많아지고 있는 추세입니다. 개발자 길을 택했다면 당연히 감수해야할 부분이라고 할 수 있겠어요!!^^^^ .. 서론이 너무 길었네요. 자, 그럼 본격적으로 왜 함수형프로그래밍이 뭔지 알아보도록 합시다! 렛츠고! ♬ . . . . 함수형 프로그래밍의 정의.. 함수형 프로그래밍은 성공적인 프로그래밍을 위해 부수 효과를 최소화하고 조합성을 강조하는 프로그래밍 패러다임이다. . . 여기서 부수효과를 최소화한다는 것은 순수함수를 만든다는 것. 순수함수는 들어온 인자가 같으면 항상 동일한 결과를 리턴하는 함수입니다. 함수가 받은 인자 외에 다른 외부상태에 영향을 끼치지도 받지도 않아야 하구요. 또한 리턴값 외에는 외부와 소통하는 것이 없는 함수를 말합니다. 순수함수로만 만들어지면 오류를 줄이고 안정성을 높일 수 있습니다. 조합성을 강조한다는 것은 모듈화 수준을 높인다는 것으로, 순수함수로 모듈화수준을 높이게 되면 생산성이 높은 프로그래밍을 할 수 있습니다. 결론적으로, 생산성이 높은 프로그래밍의 척도는 얼마나 모듈화 수준이 높느냐가 될 수 있겠습니다. 자바스크립트에서도 이러한 함수형 사고 방식으로 프로그래밍하는 것이 가능합니다. 순수 함수란? 쉽게 add라는 함수를 통해 설명하겠습니다. 12345678/* 순수 함수 */function add(a, b)&#123; return a + b;&#125;console.log(add(10,5)); //동일한 인자를 넣으면 동일한 결과를 내보냄.console.log(add(10,5)); //그리고 또다른 특징은 평가시점이 중요하지않다는것이다.console.log(add(10,5)); // 즉, 어느시점에서건 똑같은결과를 가진다. add함수는 a와 b라는 인자를 받아 a+b라는 리턴값을 내보냅니다. 이처럼 순수함수의 중요한 특징은 동일한 인자를 넣으면 동일한 결과를 내보낸다는 것입니다. 그리고 어느시점에서건 똑같은 결과를 내보냅니다. add(10,5)는 어느시점에서건 15라는 결과값을 내보낼 것입니다. 순수함수가 아닌 경우들 12345678910111213//순수함수가 아닌경우 1var c = 10;function add2(a, b)&#123; return a + b + c;&#125;console.log(add2(10,2)); //22console.log(add2(10,3));console.log(add2(10,4));c= 20;console.log(add2(10,2)); //32console.log(add2(10,3));console.log(add2(10,4)); add2라는 함수는 a와 b를 인자로 받아 a + b + c를 결과값으로 내보냅니다.여기서 만약 c가 변하지 않는 상수값이라면 add2함수는 순수함수이겠지만위처럼 중간에 값이 바뀌면 add2의 리턴값도 바뀌게 됩니다. 즉 순수함수조건에 만족하지 못합니다. 12345678//순수함수가 아닌경우 2var c = 20;function add3(a,b)&#123; c = b; return a + b;&#125;console.log(add3(20, 30)); console.log(add3(20, 30)); add3라는 함수는 a와 b라는 인자를 받아와 변수 c에 b값을 할당하고, 리턴값으로 a+b를 내보냅니다. 외부의 값에 영향을 주게 된다면 이 역시 순수함수가 될 수 없습니다. 12345678910//순수함수가 아닌경우 3var obj1 = &#123;val : 10&#125;;function add4(obj, b)&#123; obj.val += b;&#125;console.log(obj1.val); //10add4(obj1, 20);console.log(obj1.val); //30 이번에는 obj1이라는 변수를 선언하고, 이는 val속성값으로 10을 가집니다.add4라는 함수는 obj와 b라는 인자를 받아와서 obj의 val값에 인자 b의 값을 더해 값에 변화를 줍니다.console.log(obj1.val);를 하면 obj1의 val값은 10이니까 콘솔에 10이 뜨게됩니다.하지만 add4(obj1, 20);을 하는순간 obj1의 val값은 10에 20이 더해져 30이 되고,이 시점 이후에console.log(obj1.val);은 30으로 바뀝니다.평가시점이 언제건 상관없이 동일한 값을 넣으면 동일한 값을 내보내야 하는 순수함수의 조건에 만족하지 못하는 것입니다. 그렇다면 3번째 경우를 순수함수로 구현해보겠습니다.12345678910//순수 함수인 경우var obj1 = &#123;val: 10&#125;function add5(obj, b)&#123; return &#123;val: obj.val + b&#125;&#125;console.log(obj1.val); //10var obj2 = add5(obj1, 20); //30console.log(obj1.val); //10console.log(obj2.val); //30 이번에도 위랑 똑같이 obj1이라는 변수를 선언하고, val값으로 10을 주었습니다.add5는 obj와 b를 인자로 받고 val값을 obj의 val값에 b를 더한 값으로 바꿉니다.이 경우, add5(obj1, 20);를 해서 obj1의 val값인 10을 불러와 인자 b값인 20을 더한 30이라는 값을 val값으로 설정합니다.그리고 obj2라는 새로운 변수를 선언하고 {val : 30}을 할당합니다.그러면 console.log(obj1.val);은 어느 시점에서건 10이라는 똑같은 값을 리턴하고console.log(obj2.val);도 마찬가지로 30이라는 값에 변화가 없게 됩니다. 함수형 프로그래밍에서 빠질 수 없는 개념인 순수함수에 대해 배워보았어요.이번에는 순수함수와 함께 아주 중요한 개념인 일급함수에 대해 알아봅시다:) 일급 함수란?이번에도 이해를 돕기 위해 예제를 통해 공부해 봅시다. 1234567891011121314151617/* 일급 함수 */var f1 = function(a)&#123; return a*a;&#125;;cosole.log(f1);function f2(f)&#123; return f();&#125;console.log(f2(function()&#123; return 10;&#125;)); //10console.log(f2(function() &#123; return 20;&#125;)); //20 일급함수는 함수를 변화시켜서 값으로 다룰 수 있다는 것을 의미합니다.그리고 원하는 시점에서 들고 다닐 수 있고, 원하는 시점에 평가할 수도 있는것을 말합니다. 위에서 console.log(f1)을 하면 콘솔창에 function(a){return a*a};가 뜨게 됩니다. 이처럼 변수에 함수를 담을 수 있습니다. 함수 f2는 인자 f를 받아 f()를 리턴합니다. 이때 f에 function(){ return 10; }라는 함수를 담아 호출하면 10이라는 값을 리턴합니다.f2는 그대로입니다. 하지만 다른 값을 return하고 싶을때 그때그때마다 다른 인자값을 주어 함수를 호출하고 값을 리턴하는 방식입니다.그니까.. 가만히 있는 함수를 필요할때 원하는 시점에 불러와 결과값을 얻는 것입니다. 첫 포스팅이 끝났어요 !!일급함수는 순수함수랑 특징이 많이 겹치는데요. 이제 함수를 변수에 담느냐 마느냐에 따라 일급함수이냐 아니냐를 판단할 수 있어요.굳이 두가지 개념을 분리시킬 필요는 없어보여요. 하하그냥 ‘함수형 프로그래밍에선 객체지향이 아니라 일급함수!!, 순수함수!!처럼 함수지향적인 프로그래밍이다~ ‘라고만 이해하면 될것같습니다. 다음 포스팅은 map, filter를 함수형 프로그래밍으로 학습해 볼거에요ㅎㅎㅎ","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://dlalswjd95-mis.github.io/categories/Javascript/"}],"tags":[{"name":"javascript, FR","slug":"javascript-FR","permalink":"http://dlalswjd95-mis.github.io/tags/javascript-FR/"}]}]}